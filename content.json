{"meta":{"title":"Dist Blog","subtitle":null,"description":null,"author":"xiaoshuiz","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"移动离线督察功能","date":"2018-09-24T07:16:24.000Z","path":"2018/09/24/offlineremote/","text":"目录 为什么做离线督察？ 怎么做离线督察？ 应用流程 为什么做离线督察？ 离线督察优点： 不接后台，摆脱网络问题a.是否将内网映射到外网 b.是否需要挂VPN 响应速度问题报脱了等待后台相应的问题，释放等待时间，一键响应。 安全问题摆脱信息传输安全问题，不用担心信息被抓走。 离线督察优点： 数据传输数据传输只能靠物理拷贝。增加了数据传输的不方便性。 数据管理需要后台操作与存储的问题现在则需要前端来处理，还需要数据管理的部分。 怎么做离线督察？1.设备验证与用户管理 在线的设备注册可以请求后台 公钥可以请求获取 登录可以通过公钥加密后请求来实现 那离线呢？ 这就引发了我们对于这个制作的思路,从下面就是整个设计思路。 一个证书对应一个设备，一个用户，唯有对应的一台设备以及对应的一个用户才能进行通过。 用户本地可以更改密码，但是密码找回只能重新联系管理员。具体流程如下： 2.数据管理因为离线版本无后台管理数据，设备本地的资源管理器则成为了应用数据展示的UI界面。那么这个界面的信息的可阅读性，也就制约着信息的选择与使用。这些文件数据： 在应用内进行读取。 在应用外直观展示。 如何提高这个界面的信息阅读性，对于文件资源管理器，无非就是数据分级结构与文件命名。文件夹的标识则成了重要的一部分，既要展示出自己不同的地方，又要减少程序加载的资源损耗。所以本地的资源目录格式便设计成了以下结构： 3.配置文件的存放与更新 获取 相比在线的可以实时获取图斑信息，离线只能读取本地的配置文件，且配置文件中只有图斑的名字，图斑的督察情况详情需要我们通过遍历文件来获取。由于数据复杂，在应用运行期间只会遍历获取一次。避免更新数据时卡顿。 刷新 由于图斑的督察会实时变更本地文件与文件夹信息，所以之前遍历的所有数据随时都在变更。但我们并不会再重新去遍历数据。则需要程序模拟出存储逻辑过程，准确更改本地信息，不会再去遍历本地数据。且避免无效路径。 4.图版上传 图版上传？一听这个名字就知道是在线功能，那么离线怎么实现呢？图斑锁定！除了和图版上传同样验证是否完成了多媒体和督察信息。 将上传图版变更为锁定图版 将批量上传变更为批量锁定 选择锁定图版之后无法在对多媒体文档以及督察信息进行编辑，只能进行查看。 待用户完全督察完成后，进行批量拷贝。 应用流程 结语&emsp;&emsp;从数据管理方面，Android作为前端设备，摒弃了后台独立开发的话，难免在数据管理与数据处理上感到吃力，放弃了信息传输的话，应用只能是个工具，不再是个平台。 &emsp;&emsp;从数据更新方面，实时的更新数据只能单方面的去模拟数据处理流程，对于应用外的干预，无法实时发现与做出相应。 &emsp;&emsp;从开发经验方面，通过这样的应用开发，让我了解并熟悉了移动督察的实质，操作逻辑与应用流程。对接下来的开发有着莫大的帮助。 &emsp;","raw":"---\ntitle: 移动离线督察功能\ndate: 2018-09-24 15:16:24\ntags: Android\ncategories: 张泉\n---\n<header> \n<td bgcolor=#0099ff>   \n<img src=\"https://i.imgur.com/7FykwPD.jpg\"  align=\"center\"/>\n   \n\n</td>\n\n</header>\n\n<br>\n\n* <font size=\"8\" face=\"黑体\" color=#51aa51 >**目录**</font>\n\n\n\n1. <font size=\"5\" face=\"黑体\" color=#000000 >**为什么做离线督察？**</font><br>\n\n\n2. <font size=\"5\" face=\"黑体\" color=#000000 >**怎么做离线督察？**</font><br>\n\n\n3. <font size=\"5\" face=\"黑体\" color=#000000 >**应用流程**</font><br>\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#ffb022 >**为什么**</font><font size=\"6\" face=\"黑体\" color=#005432 >**做离线督察？**</font>\n\n> 离线督察优点：\n\n\n\n1. 不接后台，摆脱网络问题<br>\na.是否将内网映射到外网   b.是否需要挂VPN\n<br>\n\n\n2. 响应速度问题<br>\n报脱了等待后台相应的问题，释放等待时间，一键响应。\n<br>\n\n\n3. 安全问题<br>\n摆脱信息传输安全问题，不用担心信息被抓走。\n<br>\n\n> 离线督察优点：\n\n\n1. 数据传输<br>\n数据传输只能靠物理拷贝。增加了数据传输的不方便性。\n<br>\n\n\n2. 数据管理<br>\n需要后台操作与存储的问题现在则需要前端来处理，还需要数据管理的部分。\n<br>\n\n\n\n\n\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#ffb022 >**怎么**</font><font size=\"6\" face=\"黑体\" color=#005432 >**做离线督察？**</font>\n\n\n###  1.<font size=\"5\" face=\"黑体\"  color=#ff4444>**设备验证与用户管理**</font><br>\n\n> 在线的设备注册可以请求后台\n\n> 公钥可以请求获取\n\n> 登录可以通过公钥加密后请求来实现\n\n <br>\n那离线呢？\t这就引发了我们对于这个制作的思路,从下面就是整个设计思路。\n\n<br>\n\n<img src=\"https://i.imgur.com/GrXqZsw.png\"  align=\"center\"/>\n\n<br>\n\n一个证书对应一个设备，一个用户，唯有对应的一台设备以及对应的一个用户才能进行通过。\n\n用户本地可以更改密码，但是密码找回只能重新联系管理员。具体流程如下：\n\n<br>\n\n<img src=\"https://i.imgur.com/UBA3iWH.jpg\"  align=\"center\"/>\n    \n<br>\n\n###   2.<font size=\"5\" face=\"黑体\">**数据管理**</font><br>\n<br>\n因为离线版本无后台管理数据，设备本地的资源管理器则成为了应用数据展示的UI界面。\n<br>\n<br>\n那么这个界面的信息的可阅读性，也就制约着信息的选择与使用。\n<br>\n<br>\n这些文件数据：\n\n>在应用内进行读取。\n\n\n>在应用外直观展示。\n\n\n如何提高这个界面的信息阅读性，对于文件资源管理器，无非就是数据分级结构与文件命名。\n<br>\n<br>\n文件夹的标识则成了重要的一部分，既要展示出自己不同的地方，又要减少程序加载的资源损耗。\n<br>\n<br>\n所以本地的资源目录格式便设计成了以下结构：\n<br>\n<br>\n\n<img src=\"https://i.imgur.com/fK2GUrD.jpg\"  align=\"center\"/>\n\n\n<br>\n\n\n\t\t\n\n###  3.<font size=\"5\" face=\"黑体\">**配置文件的存放与更新**</font><br>\n\n>   获取\n\n<br>\n相比在线的可以实时获取图斑信息，离线只能读取本地的配置文件，且配置文件中只有图斑的名字，图斑的督察情况详情需要我们通过遍历文件来获取。<br>\n由于数据复杂，在应用运行期间<font color=\"ff5555\">只会遍历获取一次</font>。避免更新数据时卡顿。\n\n\t \t\t\t\n\n\n<br>\n>   刷新\n\n<br>\n由于图斑的督察会<font color=\"ff5555\">实时变更本地文件与文件夹信息</font>，所以之前遍历的所有数据随时都在变更。但我们并不会再重新去遍历数据。<br>\n则需要程序<font color=\"ff5555\">模拟出存储逻辑过程</font>，准确更改本地信息，不会再去遍历本地数据。且避免无效路径。\n\n\n\n<br>\n\n\n              \n\n###  4.<font size=\"5\" face=\"黑体\">**图版上传**</font>\n<br>\n\n\n图版上传？一听这个名字就知道是在线功能，那么离线怎么实现呢？<br><br>\n图斑锁定！除了和图版上传同样验证是否完成了多媒体和督察信息。\n\n>将上传图版变更为锁定图版\n\n\n>将批量上传变更为批量锁定\n\n\n\n选择锁定图版之后无法在对多媒体文档\n以及督察信息进行编辑，只能进行查看。\n\n待用户完全督察完成后，进行批量拷贝。\n\n\n   \n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**应用流程**</font>\n\n<br>\n<img src=\"https://i.imgur.com/DIfAzrU.jpg\"  align=\"center\"/>\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;从数据管理方面，Android作为前端设备，摒弃了后台独立开发的话，难免在数据管理与数据处理上感到吃力，放弃了信息传输的话，应用只能是个工具，不再是个平台。\n<Br>\n&emsp;&emsp;从数据更新方面，实时的更新数据只能单方面的去模拟数据处理流程，对于应用外的干预，无法实时发现与做出相应。\n<Br>\n&emsp;&emsp;从开发经验方面，通过这样的应用开发，让我了解并熟悉了移动督察的实质，操作逻辑与应用流程。对接下来的开发有着莫大的帮助。\n\n\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n\n","content":"<header><br><td bgcolor=\"#0099ff\"><br><img src=\"https://i.imgur.com/7FykwPD.jpg\" align=\"center\"><br><br><br></td><br><br></header>\n\n<p><br></p>\n<ul>\n<li><font size=\"8\" face=\"黑体\" color=\"#51aa51\"><strong>目录</strong></font>\n\n\n\n</li>\n</ul>\n<ol>\n<li><font size=\"5\" face=\"黑体\" color=\"#000000\"><strong>为什么做离线督察？</strong></font><br></li>\n</ol>\n<ol start=\"2\">\n<li><font size=\"5\" face=\"黑体\" color=\"#000000\"><strong>怎么做离线督察？</strong></font><br></li>\n</ol>\n<ol start=\"3\">\n<li><font size=\"5\" face=\"黑体\" color=\"#000000\"><strong>应用流程</strong></font><br></li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"为什么做离线督察？\"><a href=\"#为什么做离线督察？\" class=\"headerlink\" title=\"为什么做离线督察？\"></a><font size=\"6\" face=\"黑体\" color=\"#ffb022\"><strong>为什么</strong></font><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>做离线督察？</strong></font></h2><blockquote>\n<p>离线督察优点：</p>\n</blockquote>\n<ol>\n<li>不接后台，摆脱网络问题<br><br>a.是否将内网映射到外网   b.是否需要挂VPN<br><br></li>\n</ol>\n<ol start=\"2\">\n<li>响应速度问题<br><br>报脱了等待后台相应的问题，释放等待时间，一键响应。<br><br></li>\n</ol>\n<ol start=\"3\">\n<li>安全问题<br><br>摆脱信息传输安全问题，不用担心信息被抓走。<br><br></li>\n</ol>\n<blockquote>\n<p>离线督察优点：</p>\n</blockquote>\n<ol>\n<li>数据传输<br><br>数据传输只能靠物理拷贝。增加了数据传输的不方便性。<br><br></li>\n</ol>\n<ol start=\"2\">\n<li>数据管理<br><br>需要后台操作与存储的问题现在则需要前端来处理，还需要数据管理的部分。<br><br></li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"怎么做离线督察？\"><a href=\"#怎么做离线督察？\" class=\"headerlink\" title=\"怎么做离线督察？\"></a><font size=\"6\" face=\"黑体\" color=\"#ffb022\"><strong>怎么</strong></font><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>做离线督察？</strong></font></h2><h3 id=\"1-设备验证与用户管理\"><a href=\"#1-设备验证与用户管理\" class=\"headerlink\" title=\"1.设备验证与用户管理\"></a>1.<font size=\"5\" face=\"黑体\" color=\"#ff4444\"><strong>设备验证与用户管理</strong></font><br></h3><blockquote>\n<p>在线的设备注册可以请求后台</p>\n</blockquote>\n<blockquote>\n<p>公钥可以请求获取</p>\n</blockquote>\n<blockquote>\n<p>登录可以通过公钥加密后请求来实现</p>\n</blockquote>\n<p> <br><br>那离线呢？    这就引发了我们对于这个制作的思路,从下面就是整个设计思路。</p>\n<p><br></p>\n<p><img src=\"https://i.imgur.com/GrXqZsw.png\" align=\"center\"></p>\n<p><br></p>\n<p>一个证书对应一个设备，一个用户，唯有对应的一台设备以及对应的一个用户才能进行通过。</p>\n<p>用户本地可以更改密码，但是密码找回只能重新联系管理员。具体流程如下：</p>\n<p><br></p>\n<p><img src=\"https://i.imgur.com/UBA3iWH.jpg\" align=\"center\"></p>\n<p><br></p>\n<h3 id=\"2-数据管理\"><a href=\"#2-数据管理\" class=\"headerlink\" title=\"2.数据管理\"></a>2.<font size=\"5\" face=\"黑体\"><strong>数据管理</strong></font><br></h3><p><br><br>因为离线版本无后台管理数据，设备本地的资源管理器则成为了应用数据展示的UI界面。<br><br><br><br><br>那么这个界面的信息的可阅读性，也就制约着信息的选择与使用。<br><br><br><br><br>这些文件数据：</p>\n<blockquote>\n<p>在应用内进行读取。</p>\n</blockquote>\n<blockquote>\n<p>在应用外直观展示。</p>\n</blockquote>\n<p>如何提高这个界面的信息阅读性，对于文件资源管理器，无非就是数据分级结构与文件命名。<br><br><br><br><br>文件夹的标识则成了重要的一部分，既要展示出自己不同的地方，又要减少程序加载的资源损耗。<br><br><br><br><br>所以本地的资源目录格式便设计成了以下结构：<br><br><br><br></p>\n<p><img src=\"https://i.imgur.com/fK2GUrD.jpg\" align=\"center\"></p>\n<p><br></p>\n<h3 id=\"3-配置文件的存放与更新\"><a href=\"#3-配置文件的存放与更新\" class=\"headerlink\" title=\"3.配置文件的存放与更新\"></a>3.<font size=\"5\" face=\"黑体\"><strong>配置文件的存放与更新</strong></font><br></h3><blockquote>\n<p>  获取</p>\n</blockquote>\n<p><br><br>相比在线的可以实时获取图斑信息，离线只能读取本地的配置文件，且配置文件中只有图斑的名字，图斑的督察情况详情需要我们通过遍历文件来获取。<br><br>由于数据复杂，在应用运行期间<font color=\"ff5555\">只会遍历获取一次</font>。避免更新数据时卡顿。</p>\n<p><br></p>\n<blockquote>\n<p>  刷新</p>\n</blockquote>\n<p><br><br>由于图斑的督察会<font color=\"ff5555\">实时变更本地文件与文件夹信息</font>，所以之前遍历的所有数据随时都在变更。但我们并不会再重新去遍历数据。<br><br>则需要程序<font color=\"ff5555\">模拟出存储逻辑过程</font>，准确更改本地信息，不会再去遍历本地数据。且避免无效路径。</p>\n<p><br></p>\n<h3 id=\"4-图版上传\"><a href=\"#4-图版上传\" class=\"headerlink\" title=\"4.图版上传\"></a>4.<font size=\"5\" face=\"黑体\"><strong>图版上传</strong></font></h3><p><br></p>\n<p>图版上传？一听这个名字就知道是在线功能，那么离线怎么实现呢？<br><br><br>图斑锁定！除了和图版上传同样验证是否完成了多媒体和督察信息。</p>\n<blockquote>\n<p>将上传图版变更为锁定图版</p>\n</blockquote>\n<blockquote>\n<p>将批量上传变更为批量锁定</p>\n</blockquote>\n<p>选择锁定图版之后无法在对多媒体文档<br>以及督察信息进行编辑，只能进行查看。</p>\n<p>待用户完全督察完成后，进行批量拷贝。</p>\n<h2 id=\"应用流程\"><a href=\"#应用流程\" class=\"headerlink\" title=\"应用流程\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>应用流程</strong></font></h2><p><br><br><img src=\"https://i.imgur.com/DIfAzrU.jpg\" align=\"center\"></p>\n<p><hr><br><br></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font></h2><p>&emsp;&emsp;从数据管理方面，Android作为前端设备，摒弃了后台独立开发的话，难免在数据管理与数据处理上感到吃力，放弃了信息传输的话，应用只能是个工具，不再是个平台。</p>\n<p><br><br>&emsp;&emsp;从数据更新方面，实时的更新数据只能单方面的去模拟数据处理流程，对于应用外的干预，无法实时发现与做出相应。</p>\n<p><br><br>&emsp;&emsp;从开发经验方面，通过这样的应用开发，让我了解并熟悉了移动督察的实质，操作逻辑与应用流程。对接下来的开发有着莫大的帮助。</p>\n<p><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>\n\n\n","slug":"offlineremote","updated":"2018-09-28T08:09:22.004Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/09/24/offlineremote/","excerpt":"","categories":[{"name":"张泉","slug":"张泉","permalink":"http://yoursite.com/categories/张泉/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"移动图例过滤功能","date":"2018-09-24T01:16:24.000Z","path":"2018/09/24/legendfilter/","text":"移动图例过滤功能 —– &emsp; xiaoshuiz&emsp; &emsp;&emsp;&emsp; 简介图例过滤是对于多图例图层的一种查看方式，这种查看方式方便对特定类型的图块进行统一查看。多图例图层一般为DynamicLayer与FeatureLayer,而且单个图例的图层与多个图例的图层，其渲染器也是不同的，单个图例的为SimpleRenderer，多个图例为UniqueValueRenderer。在本文中，图例过滤主要为对图例进行特定过滤达到多图层互斥过滤的效果，另外对于在线图例过滤使用了Layer Definition进行图层Visible控制问题。 实现逻辑略析 可视化与相关功能操作监听的基本实现 加载功能基础的分析操作图层与其图例 单个图例的点击并获取其LabelName 在线将ArcGisDynamicServiceLayer通过ArcGisFeatureLayer加载，并获取其Renderer转为UniqueValueRenderer（离线获取FeatureLayer的Renderer） 并获取Render中的Feild1字段（配置的过滤字段） WhereClause语句的拼接（过滤字段与LabelName中的值拼接成Sql Where语句） 在线通过设置ArcGisDynamicServiceLayer的LayerDefinition（离线通过设置FeatureLayer的DefinitionExpression）进行过滤 对于在线DynamicLayer多图层控制显示问题，将Visible控制可视改为Layer Definition控制可视，只维护一套属性。 重要部分代码实现1.LayerDefinition控制可视 /** ** 根据visibleIds 更新DynamicLayer 通过DynamicLayer的Definition进行控制显示 ** Definition中 1-&gt; “1=1” 表示图层 1 全部显示 **/ //要存储的LayerDefinitions Map&lt;String, Map&lt;Integer, String&gt;&gt; dynamicLayerDefinitionMap = TotalApplication.getDynamicLayerDefinitionMap(); //要操作的LayerDefinitions Map&lt;Integer, String&gt; layerDefinitions = dynamicLayer.getLayerDefinitions(); if (layerDefinitions==null) { layerDefinitions=new HashMap&lt;&gt;(); } if (isOpenLayer) { //显示 if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) { //从存储语句中获取之前的过滤语句 for (int visibleId : visibleIds) { Map&lt;Integer, String&gt; integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl()); if (integerStringMap.containsKey(visibleId) &amp;&amp;integerStringMap.get(visibleId)!=null &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(integerStringMap.get(visibleId))) { //已存该layer的id的Layer Definition Sql 语句 layerDefinitions.put(visibleId,integerStringMap.get(visibleId)); }else { //全部显示 layerDefinitions.put(visibleId,Constants.SQL_TURE); } } }else { //全部显示 for (int visibleId : visibleIds) { layerDefinitions.put(visibleId,Constants.SQL_TURE); } } }else { //关闭 if (!layerDefinitions.isEmpty()) { Map&lt;Integer, String&gt; integerStringMap; if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) { //存储中有这个Layer的Definition integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl()); }else { //存储中没有这个layer的definition integerStringMap=new HashMap&lt;&gt;(); } for (int visibleId : visibleIds) { if (layerDefinitions.containsKey(visibleId) &amp;&amp;layerDefinitions.get(visibleId)!=null &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(layerDefinitions.get(visibleId))) { //有可视语句，进行储存 integerStringMap.put(visibleId,layerDefinitions.get(visibleId)); } //取消可视 layerDefinitions.put(visibleId,Constants.SQL_FALSE); } TotalApplication.getDynamicLayerDefinitionMap().put(dynamicLayer.getUrl(),integerStringMap); }else { //一般走不到这，避免花里胡哨的操作 for (int visibleId : visibleIds) { //取消可视 layerDefinitions.put(visibleId,Constants.SQL_FALSE); } } } dynamicLayer.setLayerDefinitions(layerDefinitions); dynamicLayer.refresh(); 2.Render获取与过滤字段获取 离线获取 离线用的FeatureLayer.getRenderer() FeatureLayer featureLayer= (FeatureLayer) layer; //判断是否获取过，避免重复查询 if (TotalApplication.getInstanceFilterFieldMap().containsKey(layerName)) { filterField=TotalApplication.getInstanceFilterFieldMap().get(layerName); }else{ //记录已查询 以免无结果 重复查询 TotalApplication.getInstanceFilterFieldMap().put(layerName,Constants.NO_FILTER_FIELD); filterField=Constants.NO_FILTER_FIELD; //获取过滤字段 Renderer renderer = featureLayer.getRenderer(); if (renderer instanceof UniqueValueRenderer) { UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer; filterField = uniqueValueRenderer.getField1(); TotalApplication.getInstanceFilterFieldMap().put(layerName,filterField); } } 在线获取 在线通过加载ArcGisFeatureLayer获取Renderer中的过滤字段 //Renderer中过滤字段的查询和保存，避免重复加载 例：RDDM if (TotalApplication.getInstanceFilterFieldMap().keySet().contains(url+Constants.SPLIT_SYMBOL[4]+layerID)) { //通知过滤 }else{ final ArcGISFeatureLayer arcGISFeatureLayer= new ArcGISFeatureLayer(url+Constants.SPLIT_SYMBOL[4]+layerID, ArcGISFeatureLayer.MODE.SELECTION); final String finalUrl = url; final String finalLayerID = layerID; arcGISFeatureLayer.setOnStatusChangedListener(new OnStatusChangedListener() { @Override public void onStatusChanged(Object o, STATUS status) { if (status== STATUS.INITIALIZED) { //记录已查询 以免无结果 重复查询 TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),Constants.NO_FILTER_FIELD); Renderer renderer = arcGISFeatureLayer.getRenderer(); if (renderer!=null) { if (renderer instanceof UniqueValueRenderer) { UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer; //获取过滤字段 RDDM String filterField = uniqueValueRenderer.getField1(); if (filterField!=null&amp;&amp;!filterField.isEmpty()) { TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),filterField); } } } //通知过滤 } } }); } 3.图例过滤 离线过滤 离线用的FeatureLayer过滤 FeatureLayer的LayerDefinition为 String (Sql Where Clause)，无需控制图层，且可以和Visible混合使用 //图例过滤 例：YDDM = &apos;mc&apos; featureLayer.setDefinitionExpression(filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+finalLegendLabel+Constants.WHERE_QUOTATION_MARKS); 在线过滤 在线用的ArcGISDynamicMapServiceLayer过滤ArcGISDynamicMapServiceLayer的LayerDefinition为Map&lt; int(layerId) , String(Sql Where Clause) &gt;，得到所需数据进行过滤 //图例过滤 if (filterField!=null&amp;&amp;!Constants.NO_FILTER_FIELD.equalsIgnoreCase(filterField)&amp;&amp;!filterField.isEmpty()) { if (layer instanceof ArcGISDynamicMapServiceLayer) { //拼组Sql Where clause 并设置LayerDefinitions 进行过滤 Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions(); if (layerDefinitions==null) { layerDefinitions=new HashMap&lt;Integer, String&gt;(); } //map中： layerId -&gt; where clause YDDM = &apos;G1&apos; layerDefinitions.put(Integer.parseInt(layerId),filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+legendName+Constants.WHERE_QUOTATION_MARKS); ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions); ((ArcGISDynamicMapServiceLayer) layer).refresh(); } } 4.结束过滤(全部显示) 离线结束过滤 Map&lt;String, Layer&gt; layerMap = TotalApplication.getInstanceAllLayerMap(); if (layerMap.containsKey(name)) { Layer layer = layerMap.get(name); if (layer instanceof FeatureLayer) { //设置LayerDefinition ((FeatureLayer) layer).setDefinitionExpression(Constants.SQL_TURE); //数据改变 legendAdapter.selectLabel= Constants.NO_SELECT; TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT); legendAdapter.notifyDataSetChanged(); } } 在线结束过滤 //获取当前layer对应的Service Layer 的URL与Id List&lt;ThemeInfo&gt; theme = oneMapActivity.mDataSource.getTheme(); for (ThemeInfo themeInfo : theme) { if (name.equalsIgnoreCase(themeInfo.getName())) { serviceUID=themeInfo.getServiceUid(); layerID=themeInfo.getLayerId(); } } List&lt;MapServicesInfo&gt; mapServices = oneMapActivity.mDataSource.getMapServices(); for (MapServicesInfo mapService : mapServices) { if (serviceUID!=null&amp;&amp;serviceUID.equalsIgnoreCase(mapService.getName())) { url=mapService.getUrl(); } } //数据改变 legendAdapter.selectLabel= Constants.NO_SELECT; TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT); legendAdapter.notifyDataSetChanged(); //TODO 通知图例过滤 全部显示 if (layer instanceof ArcGISDynamicMapServiceLayer) { Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions(); if (layerDefinitions==null){ layerDefinitions=new HashMap&lt;Integer, String&gt;(); } layerDefinitions.put(Integer.parseInt(layerId),Constants.SQL_TURE); ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions); ((ArcGISDynamicMapServiceLayer) layer).refresh(); } 结语&emsp;&emsp;图例过滤功能的开发，既减少了用户手动查找相应地块和汇总的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作地图中同一类型的地块汇总，并通过绘制图层让用户在地图上更直观的看清板块对象。 &emsp;","raw":"---\ntitle: 移动图例过滤功能\ndate: 2018-09-24 09:16:24\ntags: Android\ncategories: 张泉\n---\n\n\n\n<header> \n<td bgcolor=#0099ff>   \n\n   <center><table><tr><td bgcolor=#333333><font size =7 face=\"黑体\" color=#ffffff>**移动图例过滤功能**</td></tr></table></center>\n   \n\n</td>\n\n</header>\n<div style=\"text-align: right\"><font size=\"4\" >\n----- &emsp;\n xiaoshuiz  \n&emsp;  &emsp;&emsp;&emsp;   \n </font>\n</div>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**简介**</font>\n\n\n\n<font size=\"4\">图例过滤是对于多图例图层的一种查看方式，这种查看方式方便对特定类型的图块进行统一查看。</font>\n<br>\n<font size=\"4\">多图例图层一般为DynamicLayer与FeatureLayer,而且单个图例的图层与多个图例的图层，其渲染器也是不同的，单个图例的为SimpleRenderer，多个图例为UniqueValueRenderer。</font>\n<br>\n<font color=#664499 size=\"4\">在本文中，图例过滤主要为对图例进行特定过滤达到多图层互斥过滤的效果，另外对于在线图例过滤使用了Layer Definition进行图层Visible控制问题。</font>\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**实现逻辑略析**</font>\n\n\n1. 可视化与相关功能操作监听的基本实现<br>\n\n\n2. 加载功能基础的分析操作图层与其图例<br>\n\n\n3. 单个图例的点击并获取其LabelName<br>\n\n\n4. <font color=#664499>在线将ArcGisDynamicServiceLayer通过ArcGisFeatureLayer加载，并获取其Renderer转为UniqueValueRenderer（离线获取FeatureLayer的Renderer） 并获取Render中的Feild1字段<font color=#ee0000>（配置的过滤字段）</font></font><br>\n\n\n5. <font color =#664499>WhereClause语句的拼接（过滤字段与LabelName中的值拼接成Sql Where语句）</font><br>\n\n\n6. <font color=#664499>在线通过设置ArcGisDynamicServiceLayer的LayerDefinition（离线通过设置FeatureLayer的DefinitionExpression）进行过滤</font><br>\n\n7. 对于在线DynamicLayer多图层控制显示问题，将Visible控制可视改为Layer Definition控制可视，只维护一套属性。\n\n\n\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#ffb022 >**重要**</font><font size=\"6\" face=\"黑体\" color=#005432 >**部分代码实现**</font>\n\n\n###  1.<font size=\"5\" face=\"黑体\">**LayerDefinition控制可视**</font><br>\n\n> /** \n> \n>   **   根据visibleIds 更新DynamicLayer 通过DynamicLayer的Definition进行控制显示\n>   \n>   ** Definition中 1-> \"1=1\" 表示图层 1 全部显示\n>   \n>   **/   \n <br>\n\n\n\n\n\t\t\n        //要存储的LayerDefinitions\n        Map<String, Map<Integer, String>> dynamicLayerDefinitionMap = TotalApplication.getDynamicLayerDefinitionMap();\n        //要操作的LayerDefinitions\n        Map<Integer, String> layerDefinitions = dynamicLayer.getLayerDefinitions();\n        if (layerDefinitions==null) {\n            layerDefinitions=new HashMap<>();\n        }\n        if (isOpenLayer) {\n            //显示\n            if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n                //从存储语句中获取之前的过滤语句\n                for (int visibleId : visibleIds) {\n\n                    Map<Integer, String> integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n                    if (integerStringMap.containsKey(visibleId)\n                            &&integerStringMap.get(visibleId)!=null\n                            &&!Constants.SQL_FALSE.equalsIgnoreCase(integerStringMap.get(visibleId))) {\n                        //已存该layer的id的Layer Definition Sql 语句\n                        layerDefinitions.put(visibleId,integerStringMap.get(visibleId));\n                    }else {\n                        //全部显示\n                        layerDefinitions.put(visibleId,Constants.SQL_TURE);\n                    }\n                }\n            }else {\n                //全部显示\n                for (int visibleId : visibleIds) {\n                    layerDefinitions.put(visibleId,Constants.SQL_TURE);\n                }\n            }\n        }else {\n            //关闭\n            if (!layerDefinitions.isEmpty()) {\n                Map<Integer, String> integerStringMap;\n                if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n                    //存储中有这个Layer的Definition\n                    integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n                }else {\n                    //存储中没有这个layer的definition\n                    integerStringMap=new HashMap<>();\n                }\n                for (int visibleId : visibleIds) {\n                    if (layerDefinitions.containsKey(visibleId)\n                            &&layerDefinitions.get(visibleId)!=null\n                            &&!Constants.SQL_FALSE.equalsIgnoreCase(layerDefinitions.get(visibleId))) {\n                        //有可视语句，进行储存\n                        integerStringMap.put(visibleId,layerDefinitions.get(visibleId));\n                    }\n                    //取消可视\n                    layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n                }\n                TotalApplication.getDynamicLayerDefinitionMap().put(dynamicLayer.getUrl(),integerStringMap);\n\n            }else {\n                //一般走不到这，避免花里胡哨的操作\n                for (int visibleId : visibleIds) {\n                    //取消可视\n                    layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n                }\n            }\n        }\n        dynamicLayer.setLayerDefinitions(layerDefinitions);\n        dynamicLayer.refresh();\n    \n<br>\n\n\n###  2.<font size=\"5\" face=\"黑体\">**Render获取与过滤字段获取**</font><br>\n\n>   离线获取\n\n离线用的FeatureLayer.getRenderer()\n<br>\n\n\t \t\t\tFeatureLayer featureLayer= (FeatureLayer) layer;\n                //判断是否获取过，避免重复查询\n                if (TotalApplication.getInstanceFilterFieldMap().containsKey(layerName)) {\n                    filterField=TotalApplication.getInstanceFilterFieldMap().get(layerName);\n                }else{\n                    //记录已查询 以免无结果 重复查询\n                    TotalApplication.getInstanceFilterFieldMap().put(layerName,Constants.NO_FILTER_FIELD);\n                    filterField=Constants.NO_FILTER_FIELD;\n                    //获取过滤字段\n                    Renderer renderer = featureLayer.getRenderer();\n                    if (renderer instanceof UniqueValueRenderer) {\n                        UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n                        filterField = uniqueValueRenderer.getField1();\n                        TotalApplication.getInstanceFilterFieldMap().put(layerName,filterField);\n                    }\n                }\n\n<br>\n\n>   在线获取\n\n在线通过加载ArcGisFeatureLayer获取Renderer中的过滤字段\n<br>\n\n\t\t\n        //Renderer中过滤字段的查询和保存，避免重复加载 例：RDDM\n        if (TotalApplication.getInstanceFilterFieldMap().keySet().contains(url+Constants.SPLIT_SYMBOL[4]+layerID)) {\n            //通知过滤\n        }else{\n            final ArcGISFeatureLayer arcGISFeatureLayer= new ArcGISFeatureLayer(url+Constants.SPLIT_SYMBOL[4]+layerID, ArcGISFeatureLayer.MODE.SELECTION);\n            final String finalUrl = url;\n            final String finalLayerID = layerID;\n            arcGISFeatureLayer.setOnStatusChangedListener(new OnStatusChangedListener() {\n                @Override\n                public void onStatusChanged(Object o, STATUS status) {\n                    if (status== STATUS.INITIALIZED) {\n                        //记录已查询 以免无结果 重复查询\n                        TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),Constants.NO_FILTER_FIELD);\n                        Renderer renderer = arcGISFeatureLayer.getRenderer();\n                        if (renderer!=null) {\n\n                            if (renderer instanceof UniqueValueRenderer) {\n                                UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n                                //获取过滤字段 RDDM\n                                String filterField = uniqueValueRenderer.getField1();\n                                if (filterField!=null&&!filterField.isEmpty()) {\n                                    TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),filterField);\n                                }\n                            }\n                        }\n\t\t\t\t\t\t//通知过滤\n                    }\n\n                }\n            });\n        }  \n\n\n###  3.<font size=\"5\" face=\"黑体\" color=#ff0000>**图例过滤**</font><br>\n\n>   离线过滤\n\n离线用的FeatureLayer过滤 FeatureLayer的LayerDefinition为 String (Sql Where Clause)，\n<br>\n无需控制图层，且可以和Visible混合使用\n\n\t \t\t\t\n                \n                //图例过滤 例：YDDM = 'mc'\n                featureLayer.setDefinitionExpression(filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+finalLegendLabel+Constants.WHERE_QUOTATION_MARKS);\n\n<br>\n>   在线过滤\n\n在线用的ArcGISDynamicMapServiceLayer过滤\n<br>ArcGISDynamicMapServiceLayer的LayerDefinition为Map< int(layerId) , String(Sql Where Clause) >，\n<br>\n得到所需数据进行过滤\n<br>\n\n\t\t\t\t\n                    //图例过滤\n                    if (filterField!=null&&!Constants.NO_FILTER_FIELD.equalsIgnoreCase(filterField)&&!filterField.isEmpty()) {\n                        if (layer instanceof ArcGISDynamicMapServiceLayer) {\n                            //拼组Sql Where clause 并设置LayerDefinitions 进行过滤\n                            Map<Integer, String> layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n                            if (layerDefinitions==null) {\n                                layerDefinitions=new HashMap<Integer, String>();\n                            }\n                            //map中： layerId -> where clause   YDDM = 'G1'\n                            layerDefinitions.put(Integer.parseInt(layerId),filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+legendName+Constants.WHERE_QUOTATION_MARKS);\n                            ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n                            ((ArcGISDynamicMapServiceLayer) layer).refresh();\n                        }\n                    }\n              \n\n\n\n###  4.<font size=\"5\" face=\"黑体\" color=#ff0000>**结束过滤(全部显示)**</font><br>\n\n>  离线结束过滤\n\n\n\n\t\tMap<String, Layer> layerMap = TotalApplication.getInstanceAllLayerMap();\n        if (layerMap.containsKey(name)) {\n            Layer layer = layerMap.get(name);\n            if (layer instanceof FeatureLayer) {\n                //设置LayerDefinition\n                ((FeatureLayer) layer).setDefinitionExpression(Constants.SQL_TURE);\n                //数据改变\n                legendAdapter.selectLabel= Constants.NO_SELECT;\n                TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\n                legendAdapter.notifyDataSetChanged();\n            }\n        }\n\n<br>\n\n>  在线结束过滤\n\n\n\n\t\t//获取当前layer对应的Service Layer 的URL与Id\n        List<ThemeInfo> theme = oneMapActivity.mDataSource.getTheme();\n        for (ThemeInfo themeInfo : theme) {\n            if (name.equalsIgnoreCase(themeInfo.getName())) {\n                serviceUID=themeInfo.getServiceUid();\n                layerID=themeInfo.getLayerId();\n            }\n        }\n        List<MapServicesInfo> mapServices = oneMapActivity.mDataSource.getMapServices();\n        for (MapServicesInfo mapService : mapServices) {\n            if (serviceUID!=null&&serviceUID.equalsIgnoreCase(mapService.getName())) {\n                url=mapService.getUrl();\n            }\n        }\n        //数据改变\n        legendAdapter.selectLabel= Constants.NO_SELECT;\n        TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\n        legendAdapter.notifyDataSetChanged();\n\t\t//TODO 通知图例过滤\n\n<br>\n全部显示\n\n    if (layer instanceof ArcGISDynamicMapServiceLayer) {\n    \tMap<Integer, String> layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n        if (layerDefinitions==null){\n        \tlayerDefinitions=new HashMap<Integer, String>();\n    \t}\n    \tlayerDefinitions.put(Integer.parseInt(layerId),Constants.SQL_TURE);\n    \t((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n    \t((ArcGISDynamicMapServiceLayer) layer).refresh();\n\t}\n                \n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;图例过滤功能的开发，既减少了用户手动查找相应地块和汇总的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作地图中同一类型的地块汇总，并通过绘制图层让用户在地图上更直观的看清板块对象。\n\n\n\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n\n\n\n\n\n\n\n","content":"<p><header> </header></p>\n<td bgcolor=\"#0099ff\"><br><br>   <center><table><tr><td bgcolor=\"#333333\"><font size=\"7\" face=\"黑体\" color=\"#ffffff\"><strong>移动图例过滤功能</strong></font></td></tr></table></center><br><br><br></td>\n\n<p></p>\n<p><div style=\"text-align: right\"><font size=\"4\"><br>—– &emsp;<br> xiaoshuiz<br>&emsp;  &emsp;&emsp;&emsp;<br> </font><br></div><br><br></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>简介</strong></font></h2><font size=\"4\">图例过滤是对于多图例图层的一种查看方式，这种查看方式方便对特定类型的图块进行统一查看。</font><br><br><br><font size=\"4\">多图例图层一般为DynamicLayer与FeatureLayer,而且单个图例的图层与多个图例的图层，其渲染器也是不同的，单个图例的为SimpleRenderer，多个图例为UniqueValueRenderer。</font><br><br><br><font color=\"#664499\" size=\"4\">在本文中，图例过滤主要为对图例进行特定过滤达到多图层互斥过滤的效果，另外对于在线图例过滤使用了Layer Definition进行图层Visible控制问题。</font>\n\n<p><hr><br><br></p>\n<h2 id=\"实现逻辑略析\"><a href=\"#实现逻辑略析\" class=\"headerlink\" title=\"实现逻辑略析\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>实现逻辑略析</strong></font></h2><ol>\n<li>可视化与相关功能操作监听的基本实现<br></li>\n</ol>\n<ol start=\"2\">\n<li>加载功能基础的分析操作图层与其图例<br></li>\n</ol>\n<ol start=\"3\">\n<li>单个图例的点击并获取其LabelName<br></li>\n</ol>\n<ol start=\"4\">\n<li><font color=\"#664499\">在线将ArcGisDynamicServiceLayer通过ArcGisFeatureLayer加载，并获取其Renderer转为UniqueValueRenderer（离线获取FeatureLayer的Renderer） 并获取Render中的Feild1字段<font color=\"#ee0000\">（配置的过滤字段）</font></font><br></li>\n</ol>\n<ol start=\"5\">\n<li><font color=\"#664499\">WhereClause语句的拼接（过滤字段与LabelName中的值拼接成Sql Where语句）</font><br></li>\n</ol>\n<ol start=\"6\">\n<li><p><font color=\"#664499\">在线通过设置ArcGisDynamicServiceLayer的LayerDefinition（离线通过设置FeatureLayer的DefinitionExpression）进行过滤</font><br></p>\n</li>\n<li><p>对于在线DynamicLayer多图层控制显示问题，将Visible控制可视改为Layer Definition控制可视，只维护一套属性。</p>\n</li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"重要部分代码实现\"><a href=\"#重要部分代码实现\" class=\"headerlink\" title=\"重要部分代码实现\"></a><font size=\"6\" face=\"黑体\" color=\"#ffb022\"><strong>重要</strong></font><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>部分代码实现</strong></font></h2><h3 id=\"1-LayerDefinition控制可视\"><a href=\"#1-LayerDefinition控制可视\" class=\"headerlink\" title=\"1.LayerDefinition控制可视\"></a>1.<font size=\"5\" face=\"黑体\"><strong>LayerDefinition控制可视</strong></font><br></h3><blockquote>\n<p>/** </p>\n<p>  **   根据visibleIds 更新DynamicLayer 通过DynamicLayer的Definition进行控制显示</p>\n<p>  ** Definition中 1-&gt; “1=1” 表示图层 1 全部显示</p>\n<p>  **/<br> <br></p>\n</blockquote>\n<pre><code>//要存储的LayerDefinitions\nMap&lt;String, Map&lt;Integer, String&gt;&gt; dynamicLayerDefinitionMap = TotalApplication.getDynamicLayerDefinitionMap();\n//要操作的LayerDefinitions\nMap&lt;Integer, String&gt; layerDefinitions = dynamicLayer.getLayerDefinitions();\nif (layerDefinitions==null) {\n    layerDefinitions=new HashMap&lt;&gt;();\n}\nif (isOpenLayer) {\n    //显示\n    if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n        //从存储语句中获取之前的过滤语句\n        for (int visibleId : visibleIds) {\n\n            Map&lt;Integer, String&gt; integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n            if (integerStringMap.containsKey(visibleId)\n                    &amp;&amp;integerStringMap.get(visibleId)!=null\n                    &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(integerStringMap.get(visibleId))) {\n                //已存该layer的id的Layer Definition Sql 语句\n                layerDefinitions.put(visibleId,integerStringMap.get(visibleId));\n            }else {\n                //全部显示\n                layerDefinitions.put(visibleId,Constants.SQL_TURE);\n            }\n        }\n    }else {\n        //全部显示\n        for (int visibleId : visibleIds) {\n            layerDefinitions.put(visibleId,Constants.SQL_TURE);\n        }\n    }\n}else {\n    //关闭\n    if (!layerDefinitions.isEmpty()) {\n        Map&lt;Integer, String&gt; integerStringMap;\n        if (dynamicLayerDefinitionMap.containsKey(dynamicLayer.getUrl())) {\n            //存储中有这个Layer的Definition\n            integerStringMap = dynamicLayerDefinitionMap.get(dynamicLayer.getUrl());\n        }else {\n            //存储中没有这个layer的definition\n            integerStringMap=new HashMap&lt;&gt;();\n        }\n        for (int visibleId : visibleIds) {\n            if (layerDefinitions.containsKey(visibleId)\n                    &amp;&amp;layerDefinitions.get(visibleId)!=null\n                    &amp;&amp;!Constants.SQL_FALSE.equalsIgnoreCase(layerDefinitions.get(visibleId))) {\n                //有可视语句，进行储存\n                integerStringMap.put(visibleId,layerDefinitions.get(visibleId));\n            }\n            //取消可视\n            layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n        }\n        TotalApplication.getDynamicLayerDefinitionMap().put(dynamicLayer.getUrl(),integerStringMap);\n\n    }else {\n        //一般走不到这，避免花里胡哨的操作\n        for (int visibleId : visibleIds) {\n            //取消可视\n            layerDefinitions.put(visibleId,Constants.SQL_FALSE);\n        }\n    }\n}\ndynamicLayer.setLayerDefinitions(layerDefinitions);\ndynamicLayer.refresh();\n</code></pre><p><br></p>\n<h3 id=\"2-Render获取与过滤字段获取\"><a href=\"#2-Render获取与过滤字段获取\" class=\"headerlink\" title=\"2.Render获取与过滤字段获取\"></a>2.<font size=\"5\" face=\"黑体\"><strong>Render获取与过滤字段获取</strong></font><br></h3><blockquote>\n<p>  离线获取</p>\n</blockquote>\n<p>离线用的FeatureLayer.getRenderer()<br><br></p>\n<pre><code> FeatureLayer featureLayer= (FeatureLayer) layer;\n//判断是否获取过，避免重复查询\nif (TotalApplication.getInstanceFilterFieldMap().containsKey(layerName)) {\n    filterField=TotalApplication.getInstanceFilterFieldMap().get(layerName);\n}else{\n    //记录已查询 以免无结果 重复查询\n    TotalApplication.getInstanceFilterFieldMap().put(layerName,Constants.NO_FILTER_FIELD);\n    filterField=Constants.NO_FILTER_FIELD;\n    //获取过滤字段\n    Renderer renderer = featureLayer.getRenderer();\n    if (renderer instanceof UniqueValueRenderer) {\n        UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n        filterField = uniqueValueRenderer.getField1();\n        TotalApplication.getInstanceFilterFieldMap().put(layerName,filterField);\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线获取</p>\n</blockquote>\n<p>在线通过加载ArcGisFeatureLayer获取Renderer中的过滤字段<br><br></p>\n<pre><code>//Renderer中过滤字段的查询和保存，避免重复加载 例：RDDM\nif (TotalApplication.getInstanceFilterFieldMap().keySet().contains(url+Constants.SPLIT_SYMBOL[4]+layerID)) {\n    //通知过滤\n}else{\n    final ArcGISFeatureLayer arcGISFeatureLayer= new ArcGISFeatureLayer(url+Constants.SPLIT_SYMBOL[4]+layerID, ArcGISFeatureLayer.MODE.SELECTION);\n    final String finalUrl = url;\n    final String finalLayerID = layerID;\n    arcGISFeatureLayer.setOnStatusChangedListener(new OnStatusChangedListener() {\n        @Override\n        public void onStatusChanged(Object o, STATUS status) {\n            if (status== STATUS.INITIALIZED) {\n                //记录已查询 以免无结果 重复查询\n                TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),Constants.NO_FILTER_FIELD);\n                Renderer renderer = arcGISFeatureLayer.getRenderer();\n                if (renderer!=null) {\n\n                    if (renderer instanceof UniqueValueRenderer) {\n                        UniqueValueRenderer uniqueValueRenderer= (UniqueValueRenderer) renderer;\n                        //获取过滤字段 RDDM\n                        String filterField = uniqueValueRenderer.getField1();\n                        if (filterField!=null&amp;&amp;!filterField.isEmpty()) {\n                            TotalApplication.getInstanceFilterFieldMap().put(arcGISFeatureLayer.getUrl(),filterField);\n                        }\n                    }\n                }\n                //通知过滤\n            }\n\n        }\n    });\n}  \n</code></pre><h3 id=\"3-图例过滤\"><a href=\"#3-图例过滤\" class=\"headerlink\" title=\"3.图例过滤\"></a>3.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>图例过滤</strong></font><br></h3><blockquote>\n<p>  离线过滤</p>\n</blockquote>\n<p>离线用的FeatureLayer过滤 FeatureLayer的LayerDefinition为 String (Sql Where Clause)，<br><br><br>无需控制图层，且可以和Visible混合使用</p>\n<pre><code>//图例过滤 例：YDDM = &apos;mc&apos;\nfeatureLayer.setDefinitionExpression(filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+finalLegendLabel+Constants.WHERE_QUOTATION_MARKS);\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线过滤</p>\n</blockquote>\n<p>在线用的ArcGISDynamicMapServiceLayer过滤<br><br>ArcGISDynamicMapServiceLayer的LayerDefinition为Map&lt; int(layerId) , String(Sql Where Clause) &gt;，<br><br><br>得到所需数据进行过滤<br><br></p>\n<pre><code>//图例过滤\nif (filterField!=null&amp;&amp;!Constants.NO_FILTER_FIELD.equalsIgnoreCase(filterField)&amp;&amp;!filterField.isEmpty()) {\n    if (layer instanceof ArcGISDynamicMapServiceLayer) {\n        //拼组Sql Where clause 并设置LayerDefinitions 进行过滤\n        Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n        if (layerDefinitions==null) {\n            layerDefinitions=new HashMap&lt;Integer, String&gt;();\n        }\n        //map中： layerId -&gt; where clause   YDDM = &apos;G1&apos;\n        layerDefinitions.put(Integer.parseInt(layerId),filterField+Constants.WHERE_EQUAL+Constants.WHERE_QUOTATION_MARKS+legendName+Constants.WHERE_QUOTATION_MARKS);\n        ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n        ((ArcGISDynamicMapServiceLayer) layer).refresh();\n    }\n}\n</code></pre><h3 id=\"4-结束过滤-全部显示\"><a href=\"#4-结束过滤-全部显示\" class=\"headerlink\" title=\"4.结束过滤(全部显示)\"></a>4.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>结束过滤(全部显示)</strong></font><br></h3><blockquote>\n<p> 离线结束过滤</p>\n</blockquote>\n<pre><code>Map&lt;String, Layer&gt; layerMap = TotalApplication.getInstanceAllLayerMap();\nif (layerMap.containsKey(name)) {\n    Layer layer = layerMap.get(name);\n    if (layer instanceof FeatureLayer) {\n        //设置LayerDefinition\n        ((FeatureLayer) layer).setDefinitionExpression(Constants.SQL_TURE);\n        //数据改变\n        legendAdapter.selectLabel= Constants.NO_SELECT;\n        TotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\n        legendAdapter.notifyDataSetChanged();\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p> 在线结束过滤</p>\n</blockquote>\n<pre><code>//获取当前layer对应的Service Layer 的URL与Id\nList&lt;ThemeInfo&gt; theme = oneMapActivity.mDataSource.getTheme();\nfor (ThemeInfo themeInfo : theme) {\n    if (name.equalsIgnoreCase(themeInfo.getName())) {\n        serviceUID=themeInfo.getServiceUid();\n        layerID=themeInfo.getLayerId();\n    }\n}\nList&lt;MapServicesInfo&gt; mapServices = oneMapActivity.mDataSource.getMapServices();\nfor (MapServicesInfo mapService : mapServices) {\n    if (serviceUID!=null&amp;&amp;serviceUID.equalsIgnoreCase(mapService.getName())) {\n        url=mapService.getUrl();\n    }\n}\n//数据改变\nlegendAdapter.selectLabel= Constants.NO_SELECT;\nTotalApplication.getLayerSelectLabelMap().put(name,Constants.NO_SELECT);\nlegendAdapter.notifyDataSetChanged();\n//TODO 通知图例过滤\n</code></pre><p><br><br>全部显示</p>\n<pre><code>if (layer instanceof ArcGISDynamicMapServiceLayer) {\n    Map&lt;Integer, String&gt; layerDefinitions = ((ArcGISDynamicMapServiceLayer) layer).getLayerDefinitions();\n    if (layerDefinitions==null){\n        layerDefinitions=new HashMap&lt;Integer, String&gt;();\n    }\n    layerDefinitions.put(Integer.parseInt(layerId),Constants.SQL_TURE);\n    ((ArcGISDynamicMapServiceLayer) layer).setLayerDefinitions(layerDefinitions);\n    ((ArcGISDynamicMapServiceLayer) layer).refresh();\n}\n</code></pre><p><hr><br><br></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font></h2><p>&emsp;&emsp;图例过滤功能的开发，既减少了用户手动查找相应地块和汇总的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作地图中同一类型的地块汇总，并通过绘制图层让用户在地图上更直观的看清板块对象。</p>\n<p><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>\n\n\n\n\n\n\n\n\n","slug":"legendfilter","updated":"2018-09-28T08:09:07.302Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/09/24/legendfilter/","excerpt":"","categories":[{"name":"张泉","slug":"张泉","permalink":"http://yoursite.com/categories/张泉/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Android Gis开发经验分享","date":"2018-09-16T01:36:24.000Z","path":"2018/09/16/Android Gis开发经验分享/","text":"Android Gis开发经验分享 概述 一、地图坐标系的认识 二、地图管理类的认识 三、Gis开发熟知 四、Gis开发平台差异化注意事项 一、地图坐标系的认识 1. WGS84坐标系一种国际上采用的地心坐标系. 2. WGS84 Web墨卡托Web墨卡托是2005年谷歌在谷歌地图中首次使用的,如今主流的Web地图几乎都是使用的Web墨卡托,如：国内的百度地图、高德地图、腾讯地图和天地图等也是基于Web墨卡托（国内地图有加密要求，有两种情况，一种是在 Web墨卡托的基础上经过国家标准加密的国标02坐标系，熟称“火星坐标系”；另一种是在国标的02坐标系下进一步进行加密，如百度地图的BD09坐标系）。 3.GCJ02经纬度投影GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。 该坐标系的坐标值为经纬度格式，单位为度； GCJ02经纬度投影，就是在WGS84经纬度的基础之上，进行GCJ-02加偏；BD09经纬度投影属于百度坐标系，它是在标准经纬度的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在标准经纬度的基础之上进行了两次加偏。 4.GCJ02 Web 墨卡托投影该坐标系的坐标值为Web墨卡托格式，单位为米；这里的GCJ02 Web 墨卡托，也就是在标准Web默卡托的基础之上，进行GCJ-02加偏。 5. 北京54坐标系我国与前苏联1942年坐标系进行联测，通过计算建立了我国大地坐标系，定名为1954年北京坐标系。 它的原点不在北京而是在前苏联的普尔科沃；该坐标系存在很多缺点，为此，我国在1978年在西安召开了”全国天文大地网整体平差会议”，提出了建立属于我国自己的大地坐标系，即后来的1980西安坐标系。 6. 西安80坐标系该坐标系的大地原点设在我国中部的陕西省泾阳县永乐镇，位于西安市西北方向约60公里。 7. CGCS2000坐标系2000中国大地坐标系(China Geodetic Coordinate System 2000，CGCS2000)，又称之为2000国家大地坐标系，是中国新一代大地坐标系，21世纪初已在中国正式实施。 8. OGC标准OGC 全称是开放地理空间信息联盟(Open Geospatial Consortium),是一个非盈利的国际标准组织， 它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发可保证空间数据的互操作 9.EPSG代码EPSG的英文全称是European Petroleum Survey Group，中文名称为欧洲石油调查组织。这个组织成立于1986年，2005年并入IOGP(InternationalAssociation of Oil &amp; Gas Producers)，中文名称为国际油气生产者协会；EPSG对世界的每一个地方都制定了地图，但是由于座标系不同，所以地图也各不相同。 10.SRID：OGC标准中的参数SRID，也是指的空间参考系统的ID，与EPSG一致；天地图通常采用的4490坐标系其实也就是CGCS2000坐标系 。 二、地图管理类的认识 1. ArcGISDynamicMapServiceLayerextends DynamicLayer 2. ArcGISTiledMapServiceLayerextends TiledServiceLayer 3. ArcGISLocalTiledLayerextends TiledLayer 4. ArcGISFeatureLayerextends GraphicsLayer 5. TianDiTuLayerextends TiledServiceLayer 6. GraphicsLayerextends Layer 7. WMSLayerextends DynamicLayer 8. 其他：WMSLayer、WFS、 WMTSLayer、 WebMapLayer、 WCS、WPS、WCPS等… 其中wms是web地图服务，是一个仓库管理系统；wfs 是web要素服务，是一个工作流系统； 三、Gis开发常用函数 1.FindTask多个图层的要素查询、不能进行“空间查询”； 2. QueryTask空间和属性查询 3. IdentifyTask多个图层中查询、识别要素（Feature）； 4. OnSingleTapListener地图点击事件监听 5. calculateLength2D()线长度计算 6. polygon.calculateArea2D()面积计算 7. GeometryEngine图形交叉关系识别及计算 四、Gis平台差异化注意事项（android为主） 1.ArcGISDynamicMapServiceLayer 无法显示问题属性设置：Supports Dynamic Layers: true 2.ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。如：加载wmts地图服务后进行ArcGISDynamicMapServiceLayer叠加可进行图层显示、反之无法显示。 3.ArcGISDynamicMapServiceLayer(String url) 与ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)差异初始化传入visiblelayers，后面可通过图层id进行单个图层的控制、否则无法正常控制。 4.ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)部分地图服务必须使用此函数才可正常显示图层。项目经历：广州项目添加特有的配置文件支持该函数的使用。 问题讨论：1.三大查询的异步处理机制？ 2.地图服务操作常见问题总结。 3.天地图加载方式及注意事项。","raw":"\n---\ntitle: Android Gis开发经验分享\ndate: 2018-09-16 09:36:24\ntags: Gis\ncategories: 肖健\n---\n\n# Android Gis开发经验分享\n\n<br>\n\n## 概述\n\n<br>\n\n一、地图坐标系的认识\n\n<br>\n\n二、地图管理类的认识\n\n<br>\n\n三、Gis开发熟知\n\n<br>\n\n四、Gis开发平台差异化注意事项\n\n<br>\n\n### 一、地图坐标系的认识\n\n<br>\n\n#### 1. WGS84坐标系      \n          一种国际上采用的地心坐标系.  \n\n<br>\n\n#### 2.    WGS84 Web墨卡托\n        Web墨卡托是2005年谷歌在谷歌地图中首次使用的,如今主流的Web地图几乎都是使用的Web墨卡托,如：国内的百度地图、高德地图、腾讯地图和天地图等也是基于Web墨卡托（国内地图有加密要求，有两种情况，一种是在 Web墨卡托的基础上经过国家标准加密的国标02坐标系，熟称“火星坐标系”；另一种是在国标的02坐标系下进一步进行加密，如百度地图的BD09坐标系）。\n        \n![Alt text](https://i.imgur.com/3lj9uJ0.png)\n\n<br>\n\n#### 3.GCJ02经纬度投影\n        GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。\n        该坐标系的坐标值为经纬度格式，单位为度； GCJ02经纬度投影，就是在WGS84经纬度的基础之上，进行GCJ-02加偏；BD09经纬度投影属于百度坐标系，它是在标准经纬度的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在标准经纬度的基础之上进行了两次加偏。\n\n<br>\n\n\n#### 4.GCJ02 Web 墨卡托投影\n       该坐标系的坐标值为Web墨卡托格式，单位为米；这里的GCJ02 Web 墨卡托，也就是在标准Web默卡托的基础之上，进行GCJ-02加偏。\n\n<br>\n\n\n#### 5. 北京54坐标系\n    我国与前苏联1942年坐标系进行联测，通过计算建立了我国大地坐标系，定名为1954年北京坐标系。\n它的原点不在北京而是在前苏联的普尔科沃；该坐标系存在很多缺点，为此，我国在1978年在西安召开了\"全国天文大地网整体平差会议\"，提出了建立属于我国自己的大地坐标系，即后来的1980西安坐标系。\n\n<br>\n\n\n#### 6. 西安80坐标系\n     该坐标系的大地原点设在我国中部的陕西省泾阳县永乐镇，位于西安市西北方向约60公里。\n\n\n<br>\n\n\n\n#### 7. CGCS2000坐标系\n     2000中国大地坐标系(China Geodetic Coordinate System 2000，CGCS2000)，又称之为2000国家大地坐标系，是中国新一代大地坐标系，21世纪初已在中国正式实施。\n\n<br>\n\n\n#### 8.   OGC标准\n      OGC 全称是开放地理空间信息联盟(Open Geospatial Consortium),是一个非盈利的国际标准组织，\n它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发可保证空间数据的互操作\n\n<br>\n\n\n#### 9.EPSG代码\n      EPSG的英文全称是European Petroleum Survey Group，中文名称为欧洲石油调查组织。这个组织成立于1986年，2005年并入IOGP(InternationalAssociation of Oil & Gas Producers)，中文名称为国际油气生产者协会；EPSG对世界的每一个地方都制定了地图，但是由于座标系不同，所以地图也各不相同。\n\n<br>\n\n\n#### 10.SRID：\n\tOGC标准中的参数SRID，也是指的空间参考系统的ID，与EPSG一致；天地图通常采用的4490坐标系其实也就是CGCS2000坐标系 。\n\n![](https://i.imgur.com/0B4XQ95.png)\n![](https://i.imgur.com/66Kwr9W.png)\n\n<br>\n\n\n### 二、地图管理类的认识\n\n<br>\n\n\n#### 1. ArcGISDynamicMapServiceLayer\n                 extends DynamicLayer\n\n<br>\n\n\n#### 2. ArcGISTiledMapServiceLayer\n                 extends TiledServiceLayer\n\n<br>\n\n\n#### 3. ArcGISLocalTiledLayer\n                 extends TiledLayer\n\n<br>\n\n\n#### 4. ArcGISFeatureLayer\n                extends GraphicsLayer\n\n<br>\n\n\n#### 5. TianDiTuLayer \n                extends TiledServiceLayer\n\n<br>\n\n\n#### 6. GraphicsLayer\n                extends Layer\n\n<br>\n\n\n#### 7. WMSLayer\n               extends DynamicLayer\n\n<br>\n\n\n#### 8. 其他：\n    WMSLayer、WFS、 WMTSLayer、 WebMapLayer、 WCS、WPS、WCPS等…\n    其中wms是web地图服务，是一个仓库管理系统；wfs 是web要素服务，是一个工作流系统；\n\n![](https://i.imgur.com/kBRTMUt.png)\n\n<br>\n\n\n### 三、Gis开发常用函数\n\n<br>\n\n\n#### 1.FindTask\n     \t多个图层的要素查询、不能进行“空间查询”；\n\n<br>\n\n\n#### 2. QueryTask\n        空间和属性查询\n\n<br>\n\n\n#### 3. IdentifyTask\n       多个图层中查询、识别要素（Feature）；\n\n<br>\n\n\n#### 4. OnSingleTapListener\n\t地图点击事件监听\n\n<br>\n\n\n#### 5. calculateLength2D()\n         线长度计算\n\n<br>\n\n\n#### 6. polygon.calculateArea2D()\n         面积计算\n\n<br>\n\n\n#### 7. GeometryEngine\n      图形交叉关系识别及计算\n![](https://i.imgur.com/BezMpOa.png)\n\n<br>\n\n\n### 四、Gis平台差异化注意事项（android为主）\n\n\n<br>\n\n\n#### 1.ArcGISDynamicMapServiceLayer   无法显示问题属性设置：Supports Dynamic Layers: true\n\n<br>\n\n\n\n#### 2.ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。\n      如：加载wmts地图服务后进行ArcGISDynamicMapServiceLayer叠加可进行图层显示、反之无法显示。\n<br>\n\n\n#### 3.ArcGISDynamicMapServiceLayer(String url) 与ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)差异\n     初始化传入visiblelayers，后面可通过图层id进行单个图层的控制、否则无法正常控制。\n     \n<br>\n\n\n#### 4.ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)部分地图服务必须使用此函数才可正常显示图层。   \n     项目经历：广州项目添加特有的配置文件支持该函数的使用。\n\n<br>\n\n\n### 问题讨论：\n         1.三大查询的异步处理机制？\n         2.地图服务操作常见问题总结。\n         3.天地图加载方式及注意事项。\n\n\n\n\n\n\n\n     \n       \n\n\n\n\n","content":"<h1 id=\"Android-Gis开发经验分享\"><a href=\"#Android-Gis开发经验分享\" class=\"headerlink\" title=\"Android Gis开发经验分享\"></a>Android Gis开发经验分享</h1><p><br></p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p><br></p>\n<p>一、地图坐标系的认识</p>\n<p><br></p>\n<p>二、地图管理类的认识</p>\n<p><br></p>\n<p>三、Gis开发熟知</p>\n<p><br></p>\n<p>四、Gis开发平台差异化注意事项</p>\n<p><br></p>\n<h3 id=\"一、地图坐标系的认识\"><a href=\"#一、地图坐标系的认识\" class=\"headerlink\" title=\"一、地图坐标系的认识\"></a>一、地图坐标系的认识</h3><p><br></p>\n<h4 id=\"1-WGS84坐标系\"><a href=\"#1-WGS84坐标系\" class=\"headerlink\" title=\"1. WGS84坐标系\"></a>1. WGS84坐标系</h4><pre><code>一种国际上采用的地心坐标系.  \n</code></pre><p><br></p>\n<h4 id=\"2-WGS84-Web墨卡托\"><a href=\"#2-WGS84-Web墨卡托\" class=\"headerlink\" title=\"2.    WGS84 Web墨卡托\"></a>2.    WGS84 Web墨卡托</h4><pre><code>Web墨卡托是2005年谷歌在谷歌地图中首次使用的,如今主流的Web地图几乎都是使用的Web墨卡托,如：国内的百度地图、高德地图、腾讯地图和天地图等也是基于Web墨卡托（国内地图有加密要求，有两种情况，一种是在 Web墨卡托的基础上经过国家标准加密的国标02坐标系，熟称“火星坐标系”；另一种是在国标的02坐标系下进一步进行加密，如百度地图的BD09坐标系）。\n</code></pre><p><img src=\"https://i.imgur.com/3lj9uJ0.png\" alt=\"Alt text\"></p>\n<p><br></p>\n<h4 id=\"3-GCJ02经纬度投影\"><a href=\"#3-GCJ02经纬度投影\" class=\"headerlink\" title=\"3.GCJ02经纬度投影\"></a>3.GCJ02经纬度投影</h4><pre><code>GCJ-02是由中国国家测绘局（G表示Guojia国家，C表示Cehui测绘，J表示Ju局）制订的地理信息系统的坐标系统。它其实就是对真实坐标系统进行人为的加偏处理，按照特殊的算法，将真实的坐标加密成虚假的坐标，而这个加偏并不是线性的加偏，所以各地的偏移情况都会有所不同。而加密后的坐标也常被大家称为“火星坐标系统”。\n该坐标系的坐标值为经纬度格式，单位为度； GCJ02经纬度投影，就是在WGS84经纬度的基础之上，进行GCJ-02加偏；BD09经纬度投影属于百度坐标系，它是在标准经纬度的基础上进行GCJ-02加偏之后，再加上百度自身的加偏算法，也就是在标准经纬度的基础之上进行了两次加偏。\n</code></pre><p><br></p>\n<h4 id=\"4-GCJ02-Web-墨卡托投影\"><a href=\"#4-GCJ02-Web-墨卡托投影\" class=\"headerlink\" title=\"4.GCJ02 Web 墨卡托投影\"></a>4.GCJ02 Web 墨卡托投影</h4><pre><code>该坐标系的坐标值为Web墨卡托格式，单位为米；这里的GCJ02 Web 墨卡托，也就是在标准Web默卡托的基础之上，进行GCJ-02加偏。\n</code></pre><p><br></p>\n<h4 id=\"5-北京54坐标系\"><a href=\"#5-北京54坐标系\" class=\"headerlink\" title=\"5. 北京54坐标系\"></a>5. 北京54坐标系</h4><pre><code>我国与前苏联1942年坐标系进行联测，通过计算建立了我国大地坐标系，定名为1954年北京坐标系。\n</code></pre><p>它的原点不在北京而是在前苏联的普尔科沃；该坐标系存在很多缺点，为此，我国在1978年在西安召开了”全国天文大地网整体平差会议”，提出了建立属于我国自己的大地坐标系，即后来的1980西安坐标系。</p>\n<p><br></p>\n<h4 id=\"6-西安80坐标系\"><a href=\"#6-西安80坐标系\" class=\"headerlink\" title=\"6. 西安80坐标系\"></a>6. 西安80坐标系</h4><pre><code>该坐标系的大地原点设在我国中部的陕西省泾阳县永乐镇，位于西安市西北方向约60公里。\n</code></pre><p><br></p>\n<h4 id=\"7-CGCS2000坐标系\"><a href=\"#7-CGCS2000坐标系\" class=\"headerlink\" title=\"7. CGCS2000坐标系\"></a>7. CGCS2000坐标系</h4><pre><code>2000中国大地坐标系(China Geodetic Coordinate System 2000，CGCS2000)，又称之为2000国家大地坐标系，是中国新一代大地坐标系，21世纪初已在中国正式实施。\n</code></pre><p><br></p>\n<h4 id=\"8-OGC标准\"><a href=\"#8-OGC标准\" class=\"headerlink\" title=\"8.   OGC标准\"></a>8.   OGC标准</h4><pre><code>OGC 全称是开放地理空间信息联盟(Open Geospatial Consortium),是一个非盈利的国际标准组织，\n</code></pre><p>它制定了数据和服务的一系列标准，GIS厂商按照这个标准进行开发可保证空间数据的互操作</p>\n<p><br></p>\n<h4 id=\"9-EPSG代码\"><a href=\"#9-EPSG代码\" class=\"headerlink\" title=\"9.EPSG代码\"></a>9.EPSG代码</h4><pre><code>EPSG的英文全称是European Petroleum Survey Group，中文名称为欧洲石油调查组织。这个组织成立于1986年，2005年并入IOGP(InternationalAssociation of Oil &amp; Gas Producers)，中文名称为国际油气生产者协会；EPSG对世界的每一个地方都制定了地图，但是由于座标系不同，所以地图也各不相同。\n</code></pre><p><br></p>\n<h4 id=\"10-SRID：\"><a href=\"#10-SRID：\" class=\"headerlink\" title=\"10.SRID：\"></a>10.SRID：</h4><pre><code>OGC标准中的参数SRID，也是指的空间参考系统的ID，与EPSG一致；天地图通常采用的4490坐标系其实也就是CGCS2000坐标系 。\n</code></pre><p><img src=\"https://i.imgur.com/0B4XQ95.png\" alt=\"\"><br><img src=\"https://i.imgur.com/66Kwr9W.png\" alt=\"\"></p>\n<p><br></p>\n<h3 id=\"二、地图管理类的认识\"><a href=\"#二、地图管理类的认识\" class=\"headerlink\" title=\"二、地图管理类的认识\"></a>二、地图管理类的认识</h3><p><br></p>\n<h4 id=\"1-ArcGISDynamicMapServiceLayer\"><a href=\"#1-ArcGISDynamicMapServiceLayer\" class=\"headerlink\" title=\"1. ArcGISDynamicMapServiceLayer\"></a>1. ArcGISDynamicMapServiceLayer</h4><pre><code>extends DynamicLayer\n</code></pre><p><br></p>\n<h4 id=\"2-ArcGISTiledMapServiceLayer\"><a href=\"#2-ArcGISTiledMapServiceLayer\" class=\"headerlink\" title=\"2. ArcGISTiledMapServiceLayer\"></a>2. ArcGISTiledMapServiceLayer</h4><pre><code>extends TiledServiceLayer\n</code></pre><p><br></p>\n<h4 id=\"3-ArcGISLocalTiledLayer\"><a href=\"#3-ArcGISLocalTiledLayer\" class=\"headerlink\" title=\"3. ArcGISLocalTiledLayer\"></a>3. ArcGISLocalTiledLayer</h4><pre><code>extends TiledLayer\n</code></pre><p><br></p>\n<h4 id=\"4-ArcGISFeatureLayer\"><a href=\"#4-ArcGISFeatureLayer\" class=\"headerlink\" title=\"4. ArcGISFeatureLayer\"></a>4. ArcGISFeatureLayer</h4><pre><code>extends GraphicsLayer\n</code></pre><p><br></p>\n<h4 id=\"5-TianDiTuLayer\"><a href=\"#5-TianDiTuLayer\" class=\"headerlink\" title=\"5. TianDiTuLayer\"></a>5. TianDiTuLayer</h4><pre><code>extends TiledServiceLayer\n</code></pre><p><br></p>\n<h4 id=\"6-GraphicsLayer\"><a href=\"#6-GraphicsLayer\" class=\"headerlink\" title=\"6. GraphicsLayer\"></a>6. GraphicsLayer</h4><pre><code>extends Layer\n</code></pre><p><br></p>\n<h4 id=\"7-WMSLayer\"><a href=\"#7-WMSLayer\" class=\"headerlink\" title=\"7. WMSLayer\"></a>7. WMSLayer</h4><pre><code>extends DynamicLayer\n</code></pre><p><br></p>\n<h4 id=\"8-其他：\"><a href=\"#8-其他：\" class=\"headerlink\" title=\"8. 其他：\"></a>8. 其他：</h4><pre><code>WMSLayer、WFS、 WMTSLayer、 WebMapLayer、 WCS、WPS、WCPS等…\n其中wms是web地图服务，是一个仓库管理系统；wfs 是web要素服务，是一个工作流系统；\n</code></pre><p><img src=\"https://i.imgur.com/kBRTMUt.png\" alt=\"\"></p>\n<p><br></p>\n<h3 id=\"三、Gis开发常用函数\"><a href=\"#三、Gis开发常用函数\" class=\"headerlink\" title=\"三、Gis开发常用函数\"></a>三、Gis开发常用函数</h3><p><br></p>\n<h4 id=\"1-FindTask\"><a href=\"#1-FindTask\" class=\"headerlink\" title=\"1.FindTask\"></a>1.FindTask</h4><pre><code>多个图层的要素查询、不能进行“空间查询”；\n</code></pre><p><br></p>\n<h4 id=\"2-QueryTask\"><a href=\"#2-QueryTask\" class=\"headerlink\" title=\"2. QueryTask\"></a>2. QueryTask</h4><pre><code>空间和属性查询\n</code></pre><p><br></p>\n<h4 id=\"3-IdentifyTask\"><a href=\"#3-IdentifyTask\" class=\"headerlink\" title=\"3. IdentifyTask\"></a>3. IdentifyTask</h4><pre><code>多个图层中查询、识别要素（Feature）；\n</code></pre><p><br></p>\n<h4 id=\"4-OnSingleTapListener\"><a href=\"#4-OnSingleTapListener\" class=\"headerlink\" title=\"4. OnSingleTapListener\"></a>4. OnSingleTapListener</h4><pre><code>地图点击事件监听\n</code></pre><p><br></p>\n<h4 id=\"5-calculateLength2D\"><a href=\"#5-calculateLength2D\" class=\"headerlink\" title=\"5. calculateLength2D()\"></a>5. calculateLength2D()</h4><pre><code>线长度计算\n</code></pre><p><br></p>\n<h4 id=\"6-polygon-calculateArea2D\"><a href=\"#6-polygon-calculateArea2D\" class=\"headerlink\" title=\"6. polygon.calculateArea2D()\"></a>6. polygon.calculateArea2D()</h4><pre><code>面积计算\n</code></pre><p><br></p>\n<h4 id=\"7-GeometryEngine\"><a href=\"#7-GeometryEngine\" class=\"headerlink\" title=\"7. GeometryEngine\"></a>7. GeometryEngine</h4><pre><code>图形交叉关系识别及计算\n</code></pre><p><img src=\"https://i.imgur.com/BezMpOa.png\" alt=\"\"></p>\n<p><br></p>\n<h3 id=\"四、Gis平台差异化注意事项（android为主）\"><a href=\"#四、Gis平台差异化注意事项（android为主）\" class=\"headerlink\" title=\"四、Gis平台差异化注意事项（android为主）\"></a>四、Gis平台差异化注意事项（android为主）</h3><p><br></p>\n<h4 id=\"1-ArcGISDynamicMapServiceLayer-无法显示问题属性设置：Supports-Dynamic-Layers-true\"><a href=\"#1-ArcGISDynamicMapServiceLayer-无法显示问题属性设置：Supports-Dynamic-Layers-true\" class=\"headerlink\" title=\"1.ArcGISDynamicMapServiceLayer   无法显示问题属性设置：Supports Dynamic Layers: true\"></a>1.ArcGISDynamicMapServiceLayer   无法显示问题属性设置：Supports Dynamic Layers: true</h4><p><br></p>\n<h4 id=\"2-ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。\"><a href=\"#2-ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。\" class=\"headerlink\" title=\"2.ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。\"></a>2.ArcGISDynamicMapServiceLayer可根据底图坐标系自行调整。</h4><pre><code>如：加载wmts地图服务后进行ArcGISDynamicMapServiceLayer叠加可进行图层显示、反之无法显示。\n</code></pre><p><br></p>\n<h4 id=\"3-ArcGISDynamicMapServiceLayer-String-url-与ArcGISDynamicMapServiceLayer-String-url-int-visiblelayers-差异\"><a href=\"#3-ArcGISDynamicMapServiceLayer-String-url-与ArcGISDynamicMapServiceLayer-String-url-int-visiblelayers-差异\" class=\"headerlink\" title=\"3.ArcGISDynamicMapServiceLayer(String url) 与ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)差异\"></a>3.ArcGISDynamicMapServiceLayer(String url) 与ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)差异</h4><pre><code>初始化传入visiblelayers，后面可通过图层id进行单个图层的控制、否则无法正常控制。\n</code></pre><p><br></p>\n<h4 id=\"4-ArcGISDynamicMapServiceLayer-String-url-int-visiblelayers-部分地图服务必须使用此函数才可正常显示图层。\"><a href=\"#4-ArcGISDynamicMapServiceLayer-String-url-int-visiblelayers-部分地图服务必须使用此函数才可正常显示图层。\" class=\"headerlink\" title=\"4.ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)部分地图服务必须使用此函数才可正常显示图层。\"></a>4.ArcGISDynamicMapServiceLayer(String url, int[] visiblelayers)部分地图服务必须使用此函数才可正常显示图层。</h4><pre><code>项目经历：广州项目添加特有的配置文件支持该函数的使用。\n</code></pre><p><br></p>\n<h3 id=\"问题讨论：\"><a href=\"#问题讨论：\" class=\"headerlink\" title=\"问题讨论：\"></a>问题讨论：</h3><pre><code>1.三大查询的异步处理机制？\n2.地图服务操作常见问题总结。\n3.天地图加载方式及注意事项。\n</code></pre>","slug":"Android Gis开发经验分享","updated":"2018-09-28T08:50:35.579Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/09/16/Android Gis开发经验分享/","excerpt":"","categories":[{"name":"肖健","slug":"肖健","permalink":"http://yoursite.com/categories/肖健/"}],"tags":[{"name":"Gis","slug":"Gis","permalink":"http://yoursite.com/tags/Gis/"}]},{"title":"移动一张图专题分析","date":"2018-08-16T02:16:24.000Z","path":"2018/08/16/移动一张图专题分析-陈光禄/","text":"移动一张图专题分析 简介[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。] 列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。 逻辑列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。 当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。 当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当”parentLayerId!=-1”时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。 Windows平台/AndroidStudio开发环境重要代码实现 1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：1234567891011121314151617181920212223242526272829303132public void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) &#123; try &#123; List&lt;ThemeInfo&gt; themeInfoList=TopicLayerManager.getSubTopicList(context, projectId); if (null != themeInfoList) &#123; if (null != showList) &#123; showList.clear(); &#125; &#125; listViewSetAdapter(themeInfoList);if (!isOnlyShow &amp;&amp; null != themeInfoList &amp;&amp; themeInfoList.size() &gt; 0) &#123; TotalApplication.getListIdInstance().clear(); TotalApplication.getListIdInstance().add(projectId); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;public synchronized void listViewSetAdapter(List&lt;ThemeInfo&gt; dmpList) &#123; if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) &#123; if (null == projectAdapter) &#123; if (null != this.themeListView) &#123; this.showList = dmpList; projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData); this.themeListView.setAdapter(projectAdapter); &#125; &#125; else &#123; this.showList = dmpList; projectAdapter.setThemeInfoList(this.showList); &#125; &#125; &#125; 2. 列表Item的点击事件：12345678910111213141516171819202122232425262728293031323334353637383940414243public synchronized void clickItemResponse(Context context, int position) throws Exception &#123; if (null != showList) &#123; ThemeInfo node = showList.get(position); if (JudgeNullUtil.ObjIsNull(node)) &#123; return; &#125; List&lt;ThemeInfo&gt; dmpList = new ArrayList&lt;&gt;(); String projectId = node.getId(); String type = node.getType(); if (projectId != null &amp;&amp; projectId.length() &gt; 0 &amp;&amp; Constants.TYPE_CATLOG.equals(type)) &#123; dmpList = TopicLayerManager.getSubTopicList(context, projectId); &#125; if (null != dmpList &amp;&amp; dmpList.size() &gt; 0) &#123; if (isGradedData) &#123; if (projectId != null &amp;&amp; projectId.length() &gt; 0) &#123; if (!node.isLeaf()) &#123; node.setExpand(!node.isExpand()); if (node.isExpand()) &#123; for (ThemeInfo cNode : dmpList) &#123; cNode.setLevel(node.getLevel() + 1); &#125; showList.addAll(position + 1, dmpList); listViewSetAdapter(showList); &#125; else &#123; List&lt;ThemeInfo&gt; rmList = new ArrayList&lt;&gt;(); TopicUtil.getAllChildren(node, rmList, showList, false); showList.removeAll(rmList); listViewSetAdapter(showList); &#125; TotalApplication.getListIdInstance().add(projectId); &#125; &#125; &#125; else &#123; if (projectId != null &amp;&amp; projectId.length() &gt; 0) &#123; showList = dmpList; listViewSetAdapter(showList); TotalApplication.getListIdInstance().add(projectId); &#125; &#125; &#125; &#125;&#125; 3. 开关按钮的点击事件：public static void projectSwitch(Context context, Handler handler, List&lt;ThemeInfo&gt; themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) { List&lt;ThemeInfo&gt; parents = new ArrayList&lt;&gt;(); TopicUtil.getAllParent(info, parents, themeInfoList, false); List&lt;ThemeInfo&gt; childrens = new ArrayList&lt;&gt;(); TopicUtil.getAllChildren(info, childrens, themeInfoList, false); String openStatus = info.getOpenStatus(); if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) { finalHolder.isOpen.setImageResource(R.mipmap.topic_off); info.setOpenStatus(Constants.TOPIC_STATUS_OFF); TopicUtil.closeCurrentNode(info, themeInfoList, false); } else { finalHolder.isOpen.setImageResource(R.mipmap.topic_on); info.setOpenStatus(Constants.TOPIC_STATUS_ON); for (ThemeInfo node : childrens) { node.setOpenStatus(Constants.TOPIC_STATUS_ON); } for (ThemeInfo node : parents) { node.setOpenStatus(Constants.TOPIC_STATUS_ON); } } if (JudgeNullUtil.ObjIsNull(info)) { return; } TopicUtil.topicSwitchVisible(context, info, handler, isGradedData); } 4.通过图层id显示专题图层：/** * 通过图层id显示专题图层。 * * @param context 上下文 * @param visibleInfos 当前需要显示的图层 */ public static void setLayerVisible(Context context, List&lt;ThemeInfo&gt; visibleInfos, String currentStatus) throws Exception { if (JudgeNullUtil.ObjIsNull(visibleInfos)) { return; } boolean isOpenLayer = false; if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) { isOpenLayer = true; } if(App.isOnLineData){ onlineVisibleLayer(context, visibleInfos, isOpenLayer); }else{ offlineVisibleLayer(visibleInfos,isOpenLayer); } } 5.更新专题数据：/** * 更新专题某一层级数据或整个专题数据源 */ public static void updateThemeList(Context context, List&lt;ThemeInfo&gt; themeList) throws Exception { App appCtx = (App) context.getApplicationContext(); appCtx.getDataSource().setTheme(themeList); } /** * 更新子级目录专题数据 */ public static List&lt;ThemeInfo&gt; updateSubData(ThemeInfo subThemeInfo, List&lt;ThemeInfo&gt; themeList) throws Exception { if (subThemeInfo == null) { return themeList; } String currentId = subThemeInfo.getId(); if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) { return themeList; } List&lt;String&gt; subLayerIds = getSubLayerIds(currentId, themeList); if (JudgeNullUtil.ObjIsNull(subLayerIds)) { return themeList; } assert subLayerIds != null; for (int i = 0; i &lt; subLayerIds.size(); i++) { String subId = subLayerIds.get(i); subThemeInfo.setId(subId); String type = getThemeType(subThemeInfo, themeList); updateCurrentData(subThemeInfo, themeList); if (type == null) { continue; } if (type.equals(Constants.TYPE_CATLOG)) { updateSubData(subThemeInfo, themeList); } } return themeList; } 6. 更新layer数据：/** * 设置layer显示状态 * @param layer专题图层 * @param visibleIds 图层id */ public static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception { if (layer == null) { return; } if (layer instanceof ArcGISDynamicMapServiceLayer) { ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer; refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer); } else { layer.setVisible(isOpenLayer); } } /** * 根据visibleIds 更新DymicLayer * @param visibleIds layer Ids * @param dynamicLayer 当前需要刷新的图层 */ private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception { if (dynamicLayer == null) { return; } ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers(); if (visibleIds.length &gt; arcGISLayerInfos.length) { return; } ArcGISLayerInfo layerInfo; for (int index : visibleIds) { if (index &lt; 0) { continue; } layerInfo = arcGISLayerInfos[index]; if (layerInfo == null) { continue; } boolean isVisible = layerInfo.isVisible(); ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer(); if (layerParentInfo != null) { boolean parentVisible = layerParentInfo.isVisible(); if (isOpenLayer) { if (!parentVisible) { layerParentInfo.setVisible(true); } } else { if (parentVisible) { layerParentInfo.setVisible(false); } } } if (isOpenLayer) { if (!isVisible) { layerInfo.setVisible(true); } } else { if (isVisible) { layerInfo.setVisible(false); } } } if (!dynamicLayer.isVisible()) { dynamicLayer.setVisible(true); } dynamicLayer.refresh(); } 结语专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。","raw":"---\ntitle: 移动一张图专题分析\ndate: 2018-08-16 10:16:24\ntags: Android\ncategories: 陈光禄\n---\n\n# 移动一张图专题分析\n\n-----\n<br>\n\n## 简介\n[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。]\n > 列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。\n<br>\n\n## 逻辑\n列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。\n\n> * 当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。\n> * 当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当\"parentLayerId!=-1\"时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。\n<br>\n\n### [Windows平台/AndroidStudio开发环境](https://www.cnblogs.com/vikezhu/p/4606230.html)\n## 重要代码实现\n------\n<br>\n\n#### 1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：\n\n```Java\npublic void replaceAndShowListById(Context context, String projectId, boolean isOnlyShow) {\n        try {\n            List<ThemeInfo> themeInfoList=TopicLayerManager.getSubTopicList(context, projectId);\n        if (null != themeInfoList) {\n            if (null != showList) {\n                 showList.clear();\n                }\n            }\n            listViewSetAdapter(themeInfoList);\nif (!isOnlyShow && null != themeInfoList && themeInfoList.size() > 0) {\n                TotalApplication.getListIdInstance().clear();\n                TotalApplication.getListIdInstance().add(projectId);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\npublic synchronized void listViewSetAdapter(List<ThemeInfo> dmpList) {\n    if (null != dmpList && dmpList.size() > 0) {\n            if (null == projectAdapter) {\n                if (null != this.themeListView) {\n                    this.showList = dmpList;\n                 projectAdapter = new TopicAdapter(this.context, this.showList, handler, isGradedData);\n                    this.themeListView.setAdapter(projectAdapter);\n                }\n            } else {\n                this.showList = dmpList;\n                projectAdapter.setThemeInfoList(this.showList);\n            }\n        }\n    }\n\n\n```\n<br>\n\n\n#### 2. 列表Item的点击事件：\n\n```Java\n    public synchronized void clickItemResponse(Context context, int position) throws Exception {\n        if (null != showList) {\n            ThemeInfo node = showList.get(position);\n            if (JudgeNullUtil.ObjIsNull(node)) {\n                return;\n            }\n            List<ThemeInfo> dmpList = new ArrayList<>();\n            String projectId = node.getId();\n            String type = node.getType();\n            if (projectId != null && projectId.length() > 0 && Constants.TYPE_CATLOG.equals(type)) {\n                dmpList = TopicLayerManager.getSubTopicList(context, projectId);\n            }\n\n            if (null != dmpList && dmpList.size() > 0) {\n                if (isGradedData) {\n                    if (projectId != null && projectId.length() > 0) {\n                        if (!node.isLeaf()) {\n                            node.setExpand(!node.isExpand());\n                            if (node.isExpand()) {\n                                for (ThemeInfo cNode : dmpList) {\n                                    cNode.setLevel(node.getLevel() + 1);\n                                }\n                                showList.addAll(position + 1, dmpList);\n                                listViewSetAdapter(showList);\n                            } else {\n                                List<ThemeInfo> rmList = new ArrayList<>();\n                                TopicUtil.getAllChildren(node, rmList, showList, false);\n                                showList.removeAll(rmList);\n                                listViewSetAdapter(showList);\n                            }\n                            TotalApplication.getListIdInstance().add(projectId);\n                        }\n                    }\n                } else {\n                    if (projectId != null && projectId.length() > 0) {\n                        showList = dmpList;\n                        listViewSetAdapter(showList);\n                        TotalApplication.getListIdInstance().add(projectId);\n                    }\n                }\n            }\n        }\n    }\n\n\n```\n<br>\n\n\n#### 3. 开关按钮的点击事件：\n\n```Java\n public static void projectSwitch(Context context, Handler handler, List<ThemeInfo> themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, boolean isGradedData) {\n        List<ThemeInfo> parents = new ArrayList<>();\n        TopicUtil.getAllParent(info, parents, themeInfoList, false);\n\n        List<ThemeInfo> childrens = new ArrayList<>();\n        TopicUtil.getAllChildren(info, childrens, themeInfoList, false);\n        String openStatus = info.getOpenStatus();\n        if (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_off);\n            info.setOpenStatus(Constants.TOPIC_STATUS_OFF);\n            TopicUtil.closeCurrentNode(info, themeInfoList, false);\n        } else {\n            finalHolder.isOpen.setImageResource(R.mipmap.topic_on);\n            info.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            for (ThemeInfo node : childrens) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n            for (ThemeInfo node : parents) {\n                node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n            }\n        }\n        if (JudgeNullUtil.ObjIsNull(info)) {\n            return;\n        }\n        TopicUtil.topicSwitchVisible(context, info, handler, isGradedData);\n    }\n\n``` \n<br>\n\n#### 4.通过图层id显示专题图层：\n```Java\n /**\n     * 通过图层id显示专题图层。\n     *\n     * @param context      上下文\n     * @param visibleInfos 当前需要显示的图层\n     */\n    public static void setLayerVisible(Context context, List<ThemeInfo> visibleInfos, String currentStatus) throws Exception {\n        if (JudgeNullUtil.ObjIsNull(visibleInfos)) {\n            return;\n        }\n        boolean isOpenLayer = false;\n        if (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n            isOpenLayer = true;\n        }\n        if(App.isOnLineData){\n            onlineVisibleLayer(context, visibleInfos, isOpenLayer);\n        }else{\n            offlineVisibleLayer(visibleInfos,isOpenLayer);\n        }\n    }\n\n``` \n\n<br>\n\n\n#### 5.更新专题数据：\n```Java\n /**\n  * 更新专题某一层级数据或整个专题数据源\n  */\n    public static void updateThemeList(Context context, List<ThemeInfo> themeList) throws Exception {\n        App appCtx = (App) context.getApplicationContext();\n        appCtx.getDataSource().setTheme(themeList);\n    }\n /**\n     * 更新子级目录专题数据\n     */\n    public static List<ThemeInfo> updateSubData(ThemeInfo subThemeInfo, List<ThemeInfo> themeList) throws Exception {\n        if (subThemeInfo == null) {\n            return themeList;\n        }\n        String currentId = subThemeInfo.getId();\n        if (currentId == null || JudgeNullUtil.ObjIsNull(themeList)) {\n            return themeList;\n        }\n        List<String> subLayerIds = getSubLayerIds(currentId, themeList);\n        if (JudgeNullUtil.ObjIsNull(subLayerIds)) {\n            return themeList;\n        }\n        assert subLayerIds != null;\n        for (int i = 0; i < subLayerIds.size(); i++) {\n            String subId = subLayerIds.get(i);\n            subThemeInfo.setId(subId);\n            String type = getThemeType(subThemeInfo, themeList);\n            updateCurrentData(subThemeInfo, themeList);\n            if (type == null) {\n                continue;\n            }\n            if (type.equals(Constants.TYPE_CATLOG)) {\n                updateSubData(subThemeInfo, themeList);\n            }\n        }\n        return themeList;\n    }\n\n``` \n<br>\n\n\n#### 6. 更新layer数据：\n```Java\n/**\n  * 设置layer显示状态\n  * @param layer专题图层\n  * @param visibleIds 图层id\n  */\npublic static void updateLayerVisible(Layer layer, int[] visibleIds, boolean isOpenLayer) throws Exception {\n        if (layer == null) {\n            return;\n        }\n        if (layer instanceof ArcGISDynamicMapServiceLayer) {\n            ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer;\n            refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer);\n        } else {\n            layer.setVisible(isOpenLayer);\n        }\n    }\n/**\n     * 根据visibleIds 更新DymicLayer\n     * @param visibleIds   layer Ids\n     * @param dynamicLayer 当前需要刷新的图层\n     */\n    private static void refreshDynamicLayer(int[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, boolean isOpenLayer) throws Exception {\n        if (dynamicLayer == null) {\n            return;\n        }\n        ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers();\n        if (visibleIds.length > arcGISLayerInfos.length) {\n            return;\n        }\n        ArcGISLayerInfo layerInfo;\n        for (int index : visibleIds) {\n            if (index < 0) {\n                continue;\n            }\n            layerInfo = arcGISLayerInfos[index];\n            if (layerInfo == null) {\n                continue;\n            }\n            boolean isVisible = layerInfo.isVisible();\n            ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer();\n\n            if (layerParentInfo != null) {\n                boolean parentVisible = layerParentInfo.isVisible();\n                if (isOpenLayer) {\n                    if (!parentVisible) {\n                        layerParentInfo.setVisible(true);\n                    }\n                } else {\n                    if (parentVisible) {\n                        layerParentInfo.setVisible(false);\n                    }\n                }\n            }\n            if (isOpenLayer) {\n                if (!isVisible) {\n                    layerInfo.setVisible(true);\n                }\n            } else {\n                if (isVisible) {\n                    layerInfo.setVisible(false);\n                }\n            }\n        }\n        if (!dynamicLayer.isVisible()) {\n            dynamicLayer.setVisible(true);\n        }\n        dynamicLayer.refresh();\n    }\n\n``` \n---\n\n<br>\n\n\n## 结语\n专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。\n","content":"<h1 id=\"移动一张图专题分析\"><a href=\"#移动一张图专题分析\" class=\"headerlink\" title=\"移动一张图专题分析\"></a>移动一张图专题分析</h1><hr>\n<p><br></p>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>[专题模块为整个项目中的重要组成部分，也是不可或缺之一。用户可通过专题信息查看其主要层级结构和内部构造划分。对主要层级可进行收藏展示，便于直观查看。可手动点击某一层级结构打开对应图层，查看详细信息。]</p>\n<blockquote>\n<p>列表主要分为两种结构，一种为树状结构、一种为层级结构。以相同的数据模型展示不同的列表结构，便于用户选择。<br><br></p>\n</blockquote>\n<h2 id=\"逻辑\"><a href=\"#逻辑\" class=\"headerlink\" title=\"逻辑\"></a>逻辑</h2><p>列表项包括三角号小图标、收藏按钮和点击开关的按钮。根据不同情境分别设置相应的展示状态。</p>\n<blockquote>\n<ul>\n<li>当为树状结构时：首先初始化专题列表，通过Id展示最新列表。当点击Item项时，我们会记录专题的id,通过id找到子集列表数据，查看子集的type类型是否为“catalog”,如果是该类型，则会继续打开。直到我们点击Item项为“group”类型时，这时图层状态则不显示下一级别。 当我们点击开关状态时，获取子结点数据，将当前状态设置为打开，设置专题是否可见，根据id判断找到父级与子级，并更新整个专题的数据。当开关状态点击到“group”级别时，下一级别则是“layer”级别，图层状态则不显示下一级别。直接在图层上加载layer级别的数据。关闭时如果点击group级别的数据，则会直接关闭当前对应级别数据，父级状态为半开状态，如果关闭“catalog级则会将子级数据共同关闭，直到点击状态为“catalog”级别，对应“parentLayerId”=-1时，这时所有子级数据将全部关闭。</li>\n<li>当为层级结构时：当我们点击开关状态时，记录当前id,并通过id找到对应子级的信息，清空当前数据，将最新数据更新到列表上。关闭时当”parentLayerId!=-1”时,列表下方有一个按钮提示返回上一级，当点击按钮时会找到上一级别数据，将当前级别数据清空，并将父级数据展示到列表上，更新适配器。<br><br></li>\n</ul>\n</blockquote>\n<h3 id=\"Windows平台-AndroidStudio开发环境\"><a href=\"#Windows平台-AndroidStudio开发环境\" class=\"headerlink\" title=\"Windows平台/AndroidStudio开发环境\"></a><a href=\"https://www.cnblogs.com/vikezhu/p/4606230.html\" target=\"_blank\" rel=\"noopener\">Windows平台/AndroidStudio开发环境</a></h3><h2 id=\"重要代码实现\"><a href=\"#重要代码实现\" class=\"headerlink\" title=\"重要代码实现\"></a>重要代码实现</h2><hr>\n<p><br></p>\n<h4 id=\"1-通过ID获取列表，projectId刚开始传入-1-显示根目录列表：\"><a href=\"#1-通过ID获取列表，projectId刚开始传入-1-显示根目录列表：\" class=\"headerlink\" title=\"1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：\"></a>1. 通过ID获取列表，projectId刚开始传入-1.显示根目录列表：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceAndShowListById</span><span class=\"params\">(Context context, String projectId, <span class=\"keyword\">boolean</span> isOnlyShow)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            List&lt;ThemeInfo&gt; themeInfoList=TopicLayerManager.getSubTopicList(context, projectId);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != themeInfoList) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != showList) &#123;</span><br><span class=\"line\">                 showList.clear();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            listViewSetAdapter(themeInfoList);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!isOnlyShow &amp;&amp; <span class=\"keyword\">null</span> != themeInfoList &amp;&amp; themeInfoList.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                TotalApplication.getListIdInstance().clear();</span><br><span class=\"line\">                TotalApplication.getListIdInstance().add(projectId);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">listViewSetAdapter</span><span class=\"params\">(List&lt;ThemeInfo&gt; dmpList)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != dmpList &amp;&amp; dmpList.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == projectAdapter) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != <span class=\"keyword\">this</span>.themeListView) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.showList = dmpList;</span><br><span class=\"line\">                 projectAdapter = <span class=\"keyword\">new</span> TopicAdapter(<span class=\"keyword\">this</span>.context, <span class=\"keyword\">this</span>.showList, handler, isGradedData);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.themeListView.setAdapter(projectAdapter);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.showList = dmpList;</span><br><span class=\"line\">                projectAdapter.setThemeInfoList(<span class=\"keyword\">this</span>.showList);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h4 id=\"2-列表Item的点击事件：\"><a href=\"#2-列表Item的点击事件：\" class=\"headerlink\" title=\"2. 列表Item的点击事件：\"></a>2. 列表Item的点击事件：</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">clickItemResponse</span><span class=\"params\">(Context context, <span class=\"keyword\">int</span> position)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != showList) &#123;</span><br><span class=\"line\">        ThemeInfo node = showList.get(position);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (JudgeNullUtil.ObjIsNull(node)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;ThemeInfo&gt; dmpList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        String projectId = node.getId();</span><br><span class=\"line\">        String type = node.getType();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (projectId != <span class=\"keyword\">null</span> &amp;&amp; projectId.length() &gt; <span class=\"number\">0</span> &amp;&amp; Constants.TYPE_CATLOG.equals(type)) &#123;</span><br><span class=\"line\">            dmpList = TopicLayerManager.getSubTopicList(context, projectId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> != dmpList &amp;&amp; dmpList.size() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isGradedData) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (projectId != <span class=\"keyword\">null</span> &amp;&amp; projectId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!node.isLeaf()) &#123;</span><br><span class=\"line\">                        node.setExpand(!node.isExpand());</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (node.isExpand()) &#123;</span><br><span class=\"line\">                            <span class=\"keyword\">for</span> (ThemeInfo cNode : dmpList) &#123;</span><br><span class=\"line\">                                cNode.setLevel(node.getLevel() + <span class=\"number\">1</span>);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                            showList.addAll(position + <span class=\"number\">1</span>, dmpList);</span><br><span class=\"line\">                            listViewSetAdapter(showList);</span><br><span class=\"line\">                        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                            List&lt;ThemeInfo&gt; rmList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">                            TopicUtil.getAllChildren(node, rmList, showList, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">                            showList.removeAll(rmList);</span><br><span class=\"line\">                            listViewSetAdapter(showList);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        TotalApplication.getListIdInstance().add(projectId);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (projectId != <span class=\"keyword\">null</span> &amp;&amp; projectId.length() &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    showList = dmpList;</span><br><span class=\"line\">                    listViewSetAdapter(showList);</span><br><span class=\"line\">                    TotalApplication.getListIdInstance().add(projectId);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h4 id=\"3-开关按钮的点击事件：\"><a href=\"#3-开关按钮的点击事件：\" class=\"headerlink\" title=\"3. 开关按钮的点击事件：\"></a>3. 开关按钮的点击事件：</h4><pre><code class=\"Java\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">projectSwitch</span><span class=\"params\">(Context context, Handler handler, List&lt;ThemeInfo&gt; themeInfoList, ThemeInfo info, TopicAdapter.ViewHolder finalHolder, <span class=\"keyword\">boolean</span> isGradedData)</span> </span>{\n       List&lt;ThemeInfo&gt; parents = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();\n       TopicUtil.getAllParent(info, parents, themeInfoList, <span class=\"keyword\">false</span>);\n\n       List&lt;ThemeInfo&gt; childrens = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();\n       TopicUtil.getAllChildren(info, childrens, themeInfoList, <span class=\"keyword\">false</span>);\n       String openStatus = info.getOpenStatus();\n       <span class=\"keyword\">if</span> (!openStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n           finalHolder.isOpen.setImageResource(R.mipmap.topic_off);\n           info.setOpenStatus(Constants.TOPIC_STATUS_OFF);\n           TopicUtil.closeCurrentNode(info, themeInfoList, <span class=\"keyword\">false</span>);\n       } <span class=\"keyword\">else</span> {\n           finalHolder.isOpen.setImageResource(R.mipmap.topic_on);\n           info.setOpenStatus(Constants.TOPIC_STATUS_ON);\n           <span class=\"keyword\">for</span> (ThemeInfo node : childrens) {\n               node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n           }\n           <span class=\"keyword\">for</span> (ThemeInfo node : parents) {\n               node.setOpenStatus(Constants.TOPIC_STATUS_ON);\n           }\n       }\n       <span class=\"keyword\">if</span> (JudgeNullUtil.ObjIsNull(info)) {\n           <span class=\"keyword\">return</span>;\n       }\n       TopicUtil.topicSwitchVisible(context, info, handler, isGradedData);\n   }\n\n</code></pre>\n<p><br></p>\n<h4 id=\"4-通过图层id显示专题图层：\"><a href=\"#4-通过图层id显示专题图层：\" class=\"headerlink\" title=\"4.通过图层id显示专题图层：\"></a>4.通过图层id显示专题图层：</h4><pre><code class=\"Java\"><span class=\"comment\">/**</span>\n<span class=\"comment\">    * 通过图层id显示专题图层。</span>\n<span class=\"comment\">    *</span>\n<span class=\"comment\">    * <span class=\"doctag\">@param</span> context      上下文</span>\n<span class=\"comment\">    * <span class=\"doctag\">@param</span> visibleInfos 当前需要显示的图层</span>\n<span class=\"comment\">    */</span>\n   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setLayerVisible</span><span class=\"params\">(Context context, List&lt;ThemeInfo&gt; visibleInfos, String currentStatus)</span> <span class=\"keyword\">throws</span> Exception </span>{\n       <span class=\"keyword\">if</span> (JudgeNullUtil.ObjIsNull(visibleInfos)) {\n           <span class=\"keyword\">return</span>;\n       }\n       <span class=\"keyword\">boolean</span> isOpenLayer = <span class=\"keyword\">false</span>;\n       <span class=\"keyword\">if</span> (!currentStatus.equals(Constants.TOPIC_STATUS_OFF)) {\n           isOpenLayer = <span class=\"keyword\">true</span>;\n       }\n       <span class=\"keyword\">if</span>(App.isOnLineData){\n           onlineVisibleLayer(context, visibleInfos, isOpenLayer);\n       }<span class=\"keyword\">else</span>{\n           offlineVisibleLayer(visibleInfos,isOpenLayer);\n       }\n   }\n\n</code></pre>\n<p><br></p>\n<h4 id=\"5-更新专题数据：\"><a href=\"#5-更新专题数据：\" class=\"headerlink\" title=\"5.更新专题数据：\"></a>5.更新专题数据：</h4><pre><code class=\"Java\"><span class=\"comment\">/**</span>\n<span class=\"comment\"> * 更新专题某一层级数据或整个专题数据源</span>\n<span class=\"comment\"> */</span>\n   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateThemeList</span><span class=\"params\">(Context context, List&lt;ThemeInfo&gt; themeList)</span> <span class=\"keyword\">throws</span> Exception </span>{\n       App appCtx = (App) context.getApplicationContext();\n       appCtx.getDataSource().setTheme(themeList);\n   }\n<span class=\"comment\">/**</span>\n<span class=\"comment\">    * 更新子级目录专题数据</span>\n<span class=\"comment\">    */</span>\n   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;ThemeInfo&gt; <span class=\"title\">updateSubData</span><span class=\"params\">(ThemeInfo subThemeInfo, List&lt;ThemeInfo&gt; themeList)</span> <span class=\"keyword\">throws</span> Exception </span>{\n       <span class=\"keyword\">if</span> (subThemeInfo == <span class=\"keyword\">null</span>) {\n           <span class=\"keyword\">return</span> themeList;\n       }\n       String currentId = subThemeInfo.getId();\n       <span class=\"keyword\">if</span> (currentId == <span class=\"keyword\">null</span> || JudgeNullUtil.ObjIsNull(themeList)) {\n           <span class=\"keyword\">return</span> themeList;\n       }\n       List&lt;String&gt; subLayerIds = getSubLayerIds(currentId, themeList);\n       <span class=\"keyword\">if</span> (JudgeNullUtil.ObjIsNull(subLayerIds)) {\n           <span class=\"keyword\">return</span> themeList;\n       }\n       <span class=\"keyword\">assert</span> subLayerIds != <span class=\"keyword\">null</span>;\n       <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; subLayerIds.size(); i++) {\n           String subId = subLayerIds.get(i);\n           subThemeInfo.setId(subId);\n           String type = getThemeType(subThemeInfo, themeList);\n           updateCurrentData(subThemeInfo, themeList);\n           <span class=\"keyword\">if</span> (type == <span class=\"keyword\">null</span>) {\n               <span class=\"keyword\">continue</span>;\n           }\n           <span class=\"keyword\">if</span> (type.equals(Constants.TYPE_CATLOG)) {\n               updateSubData(subThemeInfo, themeList);\n           }\n       }\n       <span class=\"keyword\">return</span> themeList;\n   }\n\n</code></pre>\n<p><br></p>\n<h4 id=\"6-更新layer数据：\"><a href=\"#6-更新layer数据：\" class=\"headerlink\" title=\"6. 更新layer数据：\"></a>6. 更新layer数据：</h4><pre><code class=\"Java\"><span class=\"comment\">/**</span>\n<span class=\"comment\">  * 设置layer显示状态</span>\n<span class=\"comment\">  * <span class=\"doctag\">@param</span> layer专题图层</span>\n<span class=\"comment\">  * <span class=\"doctag\">@param</span> visibleIds 图层id</span>\n<span class=\"comment\">  */</span>\n<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">updateLayerVisible</span><span class=\"params\">(Layer layer, <span class=\"keyword\">int</span>[] visibleIds, <span class=\"keyword\">boolean</span> isOpenLayer)</span> <span class=\"keyword\">throws</span> Exception </span>{\n        <span class=\"keyword\">if</span> (layer == <span class=\"keyword\">null</span>) {\n            <span class=\"keyword\">return</span>;\n        }\n        <span class=\"keyword\">if</span> (layer <span class=\"keyword\">instanceof</span> ArcGISDynamicMapServiceLayer) {\n            ArcGISDynamicMapServiceLayer dynamicLayer = (ArcGISDynamicMapServiceLayer) layer;\n            refreshDynamicLayer(visibleIds, dynamicLayer, isOpenLayer);\n        } <span class=\"keyword\">else</span> {\n            layer.setVisible(isOpenLayer);\n        }\n    }\n<span class=\"comment\">/**</span>\n<span class=\"comment\">     * 根据visibleIds 更新DymicLayer</span>\n<span class=\"comment\">     * <span class=\"doctag\">@param</span> visibleIds   layer Ids</span>\n<span class=\"comment\">     * <span class=\"doctag\">@param</span> dynamicLayer 当前需要刷新的图层</span>\n<span class=\"comment\">     */</span>\n    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">refreshDynamicLayer</span><span class=\"params\">(<span class=\"keyword\">int</span>[] visibleIds, ArcGISDynamicMapServiceLayer dynamicLayer, <span class=\"keyword\">boolean</span> isOpenLayer)</span> <span class=\"keyword\">throws</span> Exception </span>{\n        <span class=\"keyword\">if</span> (dynamicLayer == <span class=\"keyword\">null</span>) {\n            <span class=\"keyword\">return</span>;\n        }\n        ArcGISLayerInfo[] arcGISLayerInfos = dynamicLayer.getAllLayers();\n        <span class=\"keyword\">if</span> (visibleIds.length &gt; arcGISLayerInfos.length) {\n            <span class=\"keyword\">return</span>;\n        }\n        ArcGISLayerInfo layerInfo;\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index : visibleIds) {\n            <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) {\n                <span class=\"keyword\">continue</span>;\n            }\n            layerInfo = arcGISLayerInfos[index];\n            <span class=\"keyword\">if</span> (layerInfo == <span class=\"keyword\">null</span>) {\n                <span class=\"keyword\">continue</span>;\n            }\n            <span class=\"keyword\">boolean</span> isVisible = layerInfo.isVisible();\n            ArcGISLayerInfo layerParentInfo = layerInfo.getParentLayer();\n\n            <span class=\"keyword\">if</span> (layerParentInfo != <span class=\"keyword\">null</span>) {\n                <span class=\"keyword\">boolean</span> parentVisible = layerParentInfo.isVisible();\n                <span class=\"keyword\">if</span> (isOpenLayer) {\n                    <span class=\"keyword\">if</span> (!parentVisible) {\n                        layerParentInfo.setVisible(<span class=\"keyword\">true</span>);\n                    }\n                } <span class=\"keyword\">else</span> {\n                    <span class=\"keyword\">if</span> (parentVisible) {\n                        layerParentInfo.setVisible(<span class=\"keyword\">false</span>);\n                    }\n                }\n            }\n            <span class=\"keyword\">if</span> (isOpenLayer) {\n                <span class=\"keyword\">if</span> (!isVisible) {\n                    layerInfo.setVisible(<span class=\"keyword\">true</span>);\n                }\n            } <span class=\"keyword\">else</span> {\n                <span class=\"keyword\">if</span> (isVisible) {\n                    layerInfo.setVisible(<span class=\"keyword\">false</span>);\n                }\n            }\n        }\n        <span class=\"keyword\">if</span> (!dynamicLayer.isVisible()) {\n            dynamicLayer.setVisible(<span class=\"keyword\">true</span>);\n        }\n        dynamicLayer.refresh();\n    }\n\n</code></pre>\n<hr>\n<p><br></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p>专题模块的开发提高了项目的灵活性和通透性，大大缩短了用户点击搜索的时间，保证了多层级结构加载时层与层之间的联系不冲突，确保它们之间稳定性。查询时可通过坐标点查询多个图层所对应信息，大大缩短了查询效率，确保项目的顺利进行。为后期新功能迭代打下坚实基础，提高用户体验。</p>\n","slug":"移动一张图专题分析-陈光禄","updated":"2018-09-28T08:25:24.263Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/08/16/移动一张图专题分析-陈光禄/","excerpt":"","categories":[{"name":"陈光禄","slug":"陈光禄","permalink":"http://yoursite.com/categories/陈光禄/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"移动用地分析","date":"2018-08-13T01:36:24.000Z","path":"2018/08/13/landanalysis/","text":"移动用地分析功能 简介用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。 实现逻辑略析 可视化与相关功能操作窗口的基本实现 加载功能基础的地图底图与分析操作图层 分析区域的选择并获取当前图形 离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤 获得结果FeatureResult，从中获取Geometry（并非与绘制图形做过交叉处理的Geometry）与Attribute 图形切割与面积计算 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定 重要部分代码实现1.分析区域选择//通过多点集合绘制几何图形 polygon.lineTo(currentPoint); currentGraphic = new Graphic(polygon, symbol); drawLayer.updateGraphic(currentGraphicIndex,currentGraphic); pointGraphic=new Graphic(multiPoint,pointSymbol); drawLayer.updateGraphic(pointGraphicIndex,pointGraphic); multiPoint.add(currentPoint); if(lastGraphicIndex!=-1){ drawLayer.removeGraphic(lastGraphicIndex); } lastGraphic=new Graphic(currentPoint,lastSymbol); lastGraphicIndex=drawLayer.addGraphic(lastGraphic); 2.地图查询 离线查询 离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); //设置区域 if (isALL) { queryParams.setGeometry(mapView_main.getExtent()); }else { Polygon queryPolygon=measureManager.getpolygon(); queryParams.setGeometry(queryPolygon); } //设置过滤字段 queryParams.setOutFields(new String[]{&quot;*&quot;}); landAnalysisResultInfos=new ArrayList&lt;&gt;(); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; FeatureLayer featureLayer=(FeatureLayer)layer; resultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener); try { //获取结果 featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { Iterator it = featureResult.iterator(); while (it.hasNext()){ GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next(); Geometry geometry=geodatabaseFeature.getGeometry(); &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } 在线查询 在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。 QueryParameters queryParams=new QueryParameters(); Polygon Querypolygon=measureManager.getpolygon(); queryParams.setGeometry(Querypolygon); landAnalysisResultInfos=new ArrayList&lt;&gt;(); queryParams.setOutFields(new String[]{&quot;*&quot;}); List&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;(); Future&lt;FeatureResult&gt; resultFuture=null; FeatureResult featureResult=null; ArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer; QueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0)); resultFuture=queryTask.execute(queryParams, callbackListener); try { featureResult=resultFuture.get(); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } if (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) { for (Object element : featureResult) { if (element instanceof Feature) { Feature f = (Feature) element; Geometry geometry=f.getGeometry(); Map&lt;String, Object&gt; featureMap=f.getAttributes(); if(geometry!=null){ //进行图形处理 } if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) { //进行内容详情提取处理 } } } } 3.图形交叉处理 通过调用GeometeyEngine.intersect()方法获取。 Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference()); 4.面积计算 由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。 /** *通过在地图上的Area大小计算百分比与实际面积 * * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo} * @return 一个结果的数组 变更了参数数组中成员的属性 */ public static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){ /*计算实际面积 */ double MUM=0; for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { if (landResourceInfo.getYDMJ()==null) { landResourceInfos.remove(landResourceInfo); continue; } Double visualArea=landResourceInfo.getGeometry().calculateArea2D(); Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D(); Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea; landResourceInfo.setYDMJ(realArea); //累计求和 MUM=MUM+landResourceInfo.getYDMJ(); } /*分别计算百分比*/ for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) { landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100)); } return landResourceInfos; } 5.图形展示 由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。 /** * 结果列表点击效果 */ private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { resultDrawerLayer.removeAll(); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE))); resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK))); Envelope tempEnvelope = new Envelope(); landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope); Point tempPoint = tEnvelope.getCenter(); mapView_main.centerAt(tempPoint,true); } }; 结语&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。 相关关键代码查看 &emsp;","raw":"---\ntitle: 移动用地分析\ndate: 2018-08-13 09:36:24\ntags: Android\ncategories: 张泉\n---\n<header> \n<td bgcolor=#0099ff>   \n\n   <center><table><tr><td bgcolor=#333333><font size =7 face=\"黑体\" color=#ffffff>**移动用地分析功能**</td></tr></table></center>\n   \n\n</td>\n</header>\n\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**简介**</font>\n\n\n\n<font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font>\n<br>\n<font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font>\n<br>\n<font color=#664499 size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font>\n\n\n<hr>\n\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**实现逻辑略析**</font>\n\n\n1. 可视化与相关功能操作窗口的基本实现<br>\n\n\n2. 加载功能基础的地图底图与分析操作图层<br>\n\n\n3. 分析区域的选择并获取当前图形<br>\n\n\n4. <font color=#664499>离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br>\n\n\n5. <font color=#664499>获得结果FeatureResult，从中获取Geometry<font color=#ee0000>（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br>\n\n\n6. <font color =#664499>图形切割与面积计算</font><br>\n\n\n7. 通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br>\n\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**重要部分代码实现**</font>\n\n\n\n### 1.<font size=\"5\" face=\"黑体\">**分析区域选择**</font><br>\n\n\n\t//通过多点集合绘制几何图形\n\tpolygon.lineTo(currentPoint);\n\tcurrentGraphic = new Graphic(polygon, symbol);\n\tdrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\tpointGraphic=new Graphic(multiPoint,pointSymbol);\n\tdrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n\tmultiPoint.add(currentPoint);\n\tif(lastGraphicIndex!=-1){\n\t\tdrawLayer.removeGraphic(lastGraphicIndex);\n\t}\n\tlastGraphic=new Graphic(currentPoint,lastSymbol);\n\tlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n    \n<br>\n\n\n### 2.<font size=\"5\" face=\"黑体\" color=#ff0000>**地图查询**</font><br>\n\n>   离线查询\n\n离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\t//设置区域\n\tif (isALL) {\n\tqueryParams.setGeometry(mapView_main.getExtent());\n\t}else {\n\t\tPolygon queryPolygon=measureManager.getpolygon();\n\t\tqueryParams.setGeometry(queryPolygon);\n\t}\n\t//设置过滤字段\n\tqueryParams.setOutFields(new String[]{\"*\"});\n\tlandAnalysisResultInfos=new ArrayList<>();\n\tList<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();                    \n\tFuture<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tFeatureLayer featureLayer=(FeatureLayer)layer;\n\tresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\n\ttry {\n\t\t//获取结果\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tIterator it = featureResult.iterator();\n\t\t while (it.hasNext()){\n\t\tGeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n\t\tGeometry geometry=geodatabaseFeature.getGeometry();\n\t\t<String, Object> featureMap=geodatabaseFeature.getAttributes();\n\n\t\tif(geometry!=null){\n\t\t\t//进行图形处理\n\t\t}\n\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t//进行内容详情提取处理\n\t\t}\n\t}\n<br>\n>   在线查询\n\n在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。\n\n\tQueryParameters queryParams=new QueryParameters();\n\tPolygon Querypolygon=measureManager.getpolygon();\n\tqueryParams.setGeometry(Querypolygon);\n    landAnalysisResultInfos=new ArrayList<>();\n    queryParams.setOutFields(new String[]{\"*\"});\n    List<LandAnalysisResultInfo> analysisResultInfos=new ArrayList<>();\n    Future<FeatureResult> resultFuture=null;\n\tFeatureResult featureResult=null;\n\tArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\n\tQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\n\tresultFuture=queryTask.execute(queryParams, callbackListener);\n\ttry {\n\t\tfeatureResult=resultFuture.get();\n\t} catch (InterruptedException e) {\n\t\te.printStackTrace();\n\t} catch (ExecutionException e) {\n\t\te.printStackTrace();\n\t}\n\tif (featureResult!=null&&featureResult.featureCount()>0) {\n\t\tfor (Object element : featureResult) {\n\t\t\tif (element instanceof Feature) {\n\t\t\t\tFeature f = (Feature) element;\n\t\t\t\tGeometry geometry=f.getGeometry();\n\t\t\t\tMap<String, Object> featureMap=f.getAttributes();\n\t\t\t\tif(geometry!=null){\n\t\t\t\t\t//进行图形处理\n\t\t\t\t}\n\t\t\t\tif (featureMap!=null&&featureMap.size()>0) {\n\t\t\t\t\t//进行内容详情提取处理\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}        \n<br>\n\n\n### 3.<font size=\"5\" face=\"黑体\" color=#ff0000>**图形交叉处理**</font><br>\n\n>  通过调用GeometeyEngine.intersect()方法获取。\n\n\tGeometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n\n<br>\n\n\n### 4.<font size=\"5\" face=\"黑体\">**面积计算**</font><br>\n\n>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br>\n>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。\n\n\t/**\n     *通过在地图上的Area大小计算百分比与实际面积\n     *\n     * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n     * @return 一个结果的数组 变更了参数数组中成员的属性\n     */\n    public static List<LandAnalysisResultInfo> getLandPercentValue(List<LandAnalysisResultInfo> landResourceInfos){\n        /*计算实际面积 */\n        double MUM=0;\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            if (landResourceInfo.getYDMJ()==null) {\n                landResourceInfos.remove(landResourceInfo);\n                continue;\n            }\n            Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n            Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n            Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n            landResourceInfo.setYDMJ(realArea);\n\n            //累计求和\n            MUM=MUM+landResourceInfo.getYDMJ();\n        }\n        /*分别计算百分比*/\n        for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n            landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n        }\n        return landResourceInfos;\n    }\n<br>\n\n\n### 5.<font size=\"5\" face=\"黑体\">**图形展示**</font><br>\n\n>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。\n\n\t/**\n     * 结果列表点击效果\n     */\n    private AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n        @Override\n        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n            resultDrawerLayer.removeAll();\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n            resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n            Envelope tempEnvelope = new Envelope();\n            landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n            Point tempPoint = tEnvelope.getCenter();\n            mapView_main.centerAt(tempPoint,true);\n        }\n    };\n\n\n\n<hr>\n<br>\n\n\n## <font size=\"6\" face=\"黑体\" color=#005432 >**结语**</font>\n\n\n&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。\n\n<font  size = 3>[相关关键代码查看](https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90 \"点击进去作者Git\")</font>\n<br>\n<br>\n\n<image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\">\n<br>&emsp;\n\n<br>\n<hr>\n\n","content":"<header><br><td bgcolor=\"#0099ff\"><br><br>   <center><table><tr><td bgcolor=\"#333333\"><font size=\"7\" face=\"黑体\" color=\"#ffffff\"><strong>移动用地分析功能</strong></font></td></tr></table></center><br><br><br></td><br></header>\n\n\n\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>简介</strong></font></h2><font size=\"4\">用地分析是指在对地区各自然要素进行综合分析研究的基础上，按照城市规划和建设要求、用地整备工程技术的可能性和经济性，对城市规划用地进行适用性分析评定，以划出城市用地的不同等级。</font><br><br><br><font size=\"4\">另外用于查清村和农、林、牧、渔场，居民点及其以外的独立工矿企事业单位土地权属界线和村以上各级行政界线，查清各类用地面积、分布和利用状况。</font><br><br><br><font color=\"#664499\" size=\"4\">在本文中，用地分析主要实现为对所选中区域进行土地类别、面积和分布的识别与判断，计算其中各个层级占其父级的百分比以及面积情况。</font>\n\n\n<hr>\n\n<p><br></p>\n<h2 id=\"实现逻辑略析\"><a href=\"#实现逻辑略析\" class=\"headerlink\" title=\"实现逻辑略析\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>实现逻辑略析</strong></font></h2><ol>\n<li>可视化与相关功能操作窗口的基本实现<br></li>\n</ol>\n<ol start=\"2\">\n<li>加载功能基础的地图底图与分析操作图层<br></li>\n</ol>\n<ol start=\"3\">\n<li>分析区域的选择并获取当前图形<br></li>\n</ol>\n<ol start=\"4\">\n<li><font color=\"#664499\">离线调用FeatureQuery（在线调用QueryTask）进行要素查询与过滤</font><br></li>\n</ol>\n<ol start=\"5\">\n<li><font color=\"#664499\">获得结果FeatureResult，从中获取Geometry<font color=\"#ee0000\">（并非与绘制图形做过交叉处理的Geometry）</font>与Attribute</font><br></li>\n</ol>\n<ol start=\"6\">\n<li><font color=\"#664499\">图形切割与面积计算</font><br></li>\n</ol>\n<ol start=\"7\">\n<li>通过GraphicLayer进行图形展示以及图形条组与相应控件Item绑定<br></li>\n</ol>\n<p><hr><br><br></p>\n<h2 id=\"重要部分代码实现\"><a href=\"#重要部分代码实现\" class=\"headerlink\" title=\"重要部分代码实现\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>重要部分代码实现</strong></font></h2><h3 id=\"1-分析区域选择\"><a href=\"#1-分析区域选择\" class=\"headerlink\" title=\"1.分析区域选择\"></a>1.<font size=\"5\" face=\"黑体\"><strong>分析区域选择</strong></font><br></h3><pre><code>//通过多点集合绘制几何图形\npolygon.lineTo(currentPoint);\ncurrentGraphic = new Graphic(polygon, symbol);\ndrawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\npointGraphic=new Graphic(multiPoint,pointSymbol);\ndrawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\nmultiPoint.add(currentPoint);\nif(lastGraphicIndex!=-1){\n    drawLayer.removeGraphic(lastGraphicIndex);\n}\nlastGraphic=new Graphic(currentPoint,lastSymbol);\nlastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n</code></pre><p><br></p>\n<h3 id=\"2-地图查询\"><a href=\"#2-地图查询\" class=\"headerlink\" title=\"2.地图查询\"></a>2.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>地图查询</strong></font><br></h3><blockquote>\n<p>  离线查询</p>\n</blockquote>\n<p>离线查询通过初始化一个QueryParameter并设置其参数，调用FeatureLayer对象的QueryFeature方法进行查询，拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\n//设置区域\nif (isALL) {\nqueryParams.setGeometry(mapView_main.getExtent());\n}else {\n    Polygon queryPolygon=measureManager.getpolygon();\n    queryParams.setGeometry(queryPolygon);\n}\n//设置过滤字段\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();                    \nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nFeatureLayer featureLayer=(FeatureLayer)layer;\nresultFuture=featureLayer.getFeatureTable().queryFeatures(queryParams,callbackListener);\ntry {\n    //获取结果\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    Iterator it = featureResult.iterator();\n     while (it.hasNext()){\n    GeodatabaseFeature geodatabaseFeature= (GeodatabaseFeature) it.next();\n    Geometry geometry=geodatabaseFeature.getGeometry();\n    &lt;String, Object&gt; featureMap=geodatabaseFeature.getAttributes();\n\n    if(geometry!=null){\n        //进行图形处理\n    }\n    if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n        //进行内容详情提取处理\n    }\n}\n</code></pre><p><br></p>\n<blockquote>\n<p>  在线查询</p>\n</blockquote>\n<p>在线查询通过初始化一个QueryParameter并设置其参数，然后通过在线图层的URL初始化一个QueryTask，通过其对象的execute方法拿到查询结果的Geometry与Attribute。</p>\n<pre><code>QueryParameters queryParams=new QueryParameters();\nPolygon Querypolygon=measureManager.getpolygon();\nqueryParams.setGeometry(Querypolygon);\nlandAnalysisResultInfos=new ArrayList&lt;&gt;();\nqueryParams.setOutFields(new String[]{&quot;*&quot;});\nList&lt;LandAnalysisResultInfo&gt; analysisResultInfos=new ArrayList&lt;&gt;();\nFuture&lt;FeatureResult&gt; resultFuture=null;\nFeatureResult featureResult=null;\nArcGISDynamicMapServiceLayer featureLayer=(ArcGISDynamicMapServiceLayer)layer;\nQueryTask queryTask=new QueryTask(featureLayer.getQueryUrl(0));\nresultFuture=queryTask.execute(queryParams, callbackListener);\ntry {\n    featureResult=resultFuture.get();\n} catch (InterruptedException e) {\n    e.printStackTrace();\n} catch (ExecutionException e) {\n    e.printStackTrace();\n}\nif (featureResult!=null&amp;&amp;featureResult.featureCount()&gt;0) {\n    for (Object element : featureResult) {\n        if (element instanceof Feature) {\n            Feature f = (Feature) element;\n            Geometry geometry=f.getGeometry();\n            Map&lt;String, Object&gt; featureMap=f.getAttributes();\n            if(geometry!=null){\n                //进行图形处理\n            }\n            if (featureMap!=null&amp;&amp;featureMap.size()&gt;0) {\n                //进行内容详情提取处理\n            }\n        }\n    }\n}        \n</code></pre><p><br></p>\n<h3 id=\"3-图形交叉处理\"><a href=\"#3-图形交叉处理\" class=\"headerlink\" title=\"3.图形交叉处理\"></a>3.<font size=\"5\" face=\"黑体\" color=\"#ff0000\"><strong>图形交叉处理</strong></font><br></h3><blockquote>\n<p> 通过调用GeometeyEngine.intersect()方法获取。</p>\n</blockquote>\n<pre><code>Geometry geometry = GeometryEngine.intersect(geometry,measureManager.getpolygon(),mapView_main.getSpatialReference());\n</code></pre><p><br></p>\n<h3 id=\"4-面积计算\"><a href=\"#4-面积计算\" class=\"headerlink\" title=\"4.面积计算\"></a>4.<font size=\"5\" face=\"黑体\"><strong>面积计算</strong></font><br></h3><blockquote>\n<p>由于获取的Geometry的面积与其父Geometry的面积均为调用Geometry对象的calculateArea2D()方法，并非实际面积。<br><br>所以我们需要通过Attribute获得的实际面积计算切割Geometry与其父Geometry的实际面积，并计算其百分比。</p>\n</blockquote>\n<pre><code>/**\n *通过在地图上的Area大小计算百分比与实际面积\n *\n * @param landResourceInfos 分析结果的数组 成员： {@link LandAnalysisResultInfo}\n * @return 一个结果的数组 变更了参数数组中成员的属性\n */\npublic static List&lt;LandAnalysisResultInfo&gt; getLandPercentValue(List&lt;LandAnalysisResultInfo&gt; landResourceInfos){\n    /*计算实际面积 */\n    double MUM=0;\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        if (landResourceInfo.getYDMJ()==null) {\n            landResourceInfos.remove(landResourceInfo);\n            continue;\n        }\n        Double visualArea=landResourceInfo.getGeometry().calculateArea2D();\n        Double visualParentArea=landResourceInfo.getParentGeometry().calculateArea2D();\n        Double realArea=landResourceInfo.getYDMJ()/visualParentArea*visualArea;\n        landResourceInfo.setYDMJ(realArea);\n\n        //累计求和\n        MUM=MUM+landResourceInfo.getYDMJ();\n    }\n    /*分别计算百分比*/\n    for (LandAnalysisResultInfo landResourceInfo : landResourceInfos) {\n        landResourceInfo.setPercentValue(String.valueOf(landResourceInfo.getYDMJ()/MUM*100));\n    }\n    return landResourceInfos;\n}\n</code></pre><p><br></p>\n<h3 id=\"5-图形展示\"><a href=\"#5-图形展示\" class=\"headerlink\" title=\"5.图形展示\"></a>5.<font size=\"5\" face=\"黑体\"><strong>图形展示</strong></font><br></h3><blockquote>\n<p>由于本次使用为列表显示，故图形展示在点击子Item的时候进行Geometry的绘制与添加。</p>\n</blockquote>\n<pre><code>/**\n * 结果列表点击效果\n */\nprivate AdapterView.OnItemClickListener resultListOnItemClickListener =new AdapterView.OnItemClickListener() {\n    @Override\n    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {\n        resultDrawerLayer.removeAll();\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getGeometry(), MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYGON, Color.BLUE)));\n        resultDrawerLayer.addGraphic(new Graphic(landAnalysisResultInfos.get(position).getParentGeometry(),MapViewTapTool.getLabelSymbol(MainMapActivity.this,Geometry.Type.POLYLINE, Color.BLACK)));\n        Envelope tempEnvelope = new Envelope();\n        landAnalysisResultInfos.get(position).getParentGeometry().queryEnvelope(tempEnvelope);\n        Point tempPoint = tEnvelope.getCenter();\n        mapView_main.centerAt(tempPoint,true);\n    }\n};\n</code></pre><p><hr><br><br></p>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a><font size=\"6\" face=\"黑体\" color=\"#005432\"><strong>结语</strong></font></h2><p>&emsp;&emsp;用地分析功能的开发，既减少了用户查看地图计算面积的时间，提高了地图的可阅读性。让用户通过移动设备简单的操作即可获取选取区域中各类型的板块内容与面积，并通过绘制图层让用户在地图上更直观的看清板块对象。</p>\n<p><font size=\"3\"><a href=\"https://github.com/xiaoshuiz/Rep4MarkDown/tree/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81/%E7%94%A8%E5%9C%B0%E5%88%86%E6%9E%90\" title=\"点击进去作者Git\" target=\"_blank\" rel=\"noopener\">相关关键代码查看</a></font><br><br><br><br></p>\n<p><image src=\"http://www.dist.com.cn/templates/cn/images/logo.png\" align=\"right\"><br><br>&emsp;</image></p>\n<p><br></p>\n<hr>\n\n","slug":"landanalysis","updated":"2018-09-28T08:08:49.977Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/08/13/landanalysis/","excerpt":"","categories":[{"name":"张泉","slug":"张泉","permalink":"http://yoursite.com/categories/张泉/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"在线缓存功能开发分享","date":"2018-08-05T02:16:24.000Z","path":"2018/08/05/在线缓存功能开发分享-万峥嵘/","text":"1. 简介 离线在线一体化数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。 应用场景在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。 2. 在线缓存的实现逻辑思路 在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义） 获取下载滴地图服务所需要的具体参数 在本地创建文件，存放下载的数据，以供使用 3. 用到的核心功能类以及说明 GeodatabaseSyncTask类，实现下载同步功能 GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择 CallbackListener，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表List&lt;GdbFeatureTable&gt;对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。 GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。 GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。 4. 代码示例 在地图上自定义一个区域 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 /** * 绘制出在线缓存区域 * */private void polygonState(Point currentPoint)throws Exception&#123; if(startPoint!=null&amp;&amp;!startPoint.isEmpty())&#123; polygon.lineTo(currentPoint); currentGraphic = new Graphic(polygon, symbol); drawLayer.updateGraphic(currentGraphicIndex,currentGraphic); pointGraphic=new Graphic(multiPoint,pointSymbol); drawLayer.updateGraphic(pointGraphicIndex,pointGraphic); multiPoint.add(currentPoint); if(lastGraphicIndex!=-1)&#123; drawLayer.removeGraphic(lastGraphicIndex); &#125; lastGraphic=new Graphic(currentPoint,lastSymbol); lastGraphicIndex=drawLayer.addGraphic(lastGraphic); if(polygon.getPointCount()&gt;=3)&#123; isCheckedSave=true; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue)); onlinesave.setClickable(isSave); &#125; &#125;else&#123; polygon=new Polygon(); multiPoint=new MultiPoint(); polygon.startPath(currentPoint); startPoint=currentPoint; currentGraphic=new Graphic(startPoint,symbol); currentGraphicIndex=drawLayer.addGraphic(currentGraphic); pointGraphic=new Graphic(startPoint,lastSymbol); pointGraphicIndex=drawLayer.addGraphic(pointGraphic); multiPoint.add(currentPoint); &#125;&#125;/** * 确定所选区域范围 * */public void SaveLabel()throws Exception&#123; if(isSave&amp;&amp;drawLayer!=null) &#123; startPoint = null; isCheckedSave=false; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray)); onlinesave.setClickable(isSave); if(currentGraphicIndex!=-1)&#123; Graphic graphic = drawLayer.getGraphic(currentGraphicIndex); if(graphic!=null)&#123; Geometry geometry=graphic.getGeometry(); Graphic saveGraphic=null; if(geometryType.equals(Geometry.Type.POLYGON))&#123; symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent)); saveGraphic=new Graphic(geometry,symbol); pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity); pointGraphic=new Graphic(geometry,pointSymbol); &#125;else&#123; symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green)); saveGraphic=new Graphic(geometry,symbol); pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity); pointGraphic=new Graphic(geometry,pointSymbol); &#125; if(onlineCacheInfoList!=null&amp;&amp;onlineCacheInfoList.size()&gt;0)&#123; setView(); int i = 0; if(onlineCacheInfoList.get(i).getCacheurl().trim().length()&gt;0) &#123; downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer &#125; &#125; &#125; &#125; &#125;else&#123; isCheckedSave=false; isSave=isCheckedSave; onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray)); onlinesave.setClickable(isSave); &#125;&#125; 下载选定区域所对应的在线缓存的文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) &#123; gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null); gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener&lt;FeatureServiceInfo&gt;() &#123; @Override public void onError(Throwable arg0) &#123; Log.e(TAG, &quot;Error fetching FeatureServiceInfo&quot;); &#125; @Override public void onCallback(FeatureServiceInfo fsInfo) &#123; if (fsInfo.isSyncEnabled()) &#123; //回调获取所需要的下载的图层信息 createGeodatabase(onlineCacheInfo.getIds(),geometry,i); &#125; &#125; &#125;); &#125; //创建下载 private void createGeodatabase(int[] ids, final Geometry geometry, final int i) &#123; SpatialReference sp=mOneMapView.getSpatialReference(); GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE); CallbackListener&lt;String&gt; gdbResponseCallback = new CallbackListener&lt;String&gt;() &#123; @Override public void onError(final Throwable e) &#123; Log.e(TAG, &quot;Error creating geodatabase&quot;); Toast.makeText(mActivity, &quot;数据下载失败!&quot;, Toast.LENGTH_LONG).show(); pDialog.dismiss(); &#125; @Override public void onCallback(String path) &#123; updateFeatureLayer(path); if(i&lt;onlineCacheInfoList.size()&amp;&amp;onlineCacheInfoList.get(i+1).getCacheurl().trim().length()&gt;0)&#123; downloadData(onlineCacheInfoList.get(i+1),geometry,i+1); &#125;else &#123; pDialog.dismiss(); Toast.makeText(mActivity, &quot;数据下载完成!&quot;, Toast.LENGTH_LONG).show(); &#125; &#125; &#125;; localGdbFilePath = &quot;对应在本地存储的存储路径以及存储名称&quot;; submitTask(params, localGdbFilePath, statusCallback, gdbResponseCallback); &#125; private void submitTask(GenerateGeodatabaseParameters params, String file, GeodatabaseStatusCallback statusCallback, CallbackListener&lt;String&gt; gdbResponseCallback) &#123; // submit task gdbSyncTask.generateGeodatabase(params, file, false, statusCallback, gdbResponseCallback); &#125; 将下载完成的数据再地图上展示 12345678910111213141516171819//加载数据private void updateFeatureLayer(String featureLayerPath) &#123; // create a new geodatabase Geodatabase localGdb = null; try &#123; localGdb = new Geodatabase(featureLayerPath); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; if (localGdb != null) &#123; for (GeodatabaseFeatureTable gdbFeatureTable : localGdb .getGeodatabaseTables()) &#123; if (gdbFeatureTable.hasGeometry())&#123; mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable)); &#125; &#125; &#125; &#125; 5. 结语在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。 最后感谢您的阅读，有机会一起探讨！","raw":"---\ntitle: 在线缓存功能开发分享\ndate: 2018-08-05 10:16:24\ntags: Android\ncategories: 万峥嵘\n---\n<br>\n## 1. 简介\n\n\n1. 离线在线一体化\n数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。\n2. 应用场景\n在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。\n\n<br>\n\n\n## 2. 在线缓存的实现逻辑思路\n- 在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义）\n- 获取下载滴地图服务所需要的具体参数\n- 在本地创建文件，存放下载的数据，以供使用\n\n<br>\n\n\n## 3. 用到的核心功能类以及说明\n- GeodatabaseSyncTask类，实现下载同步功能\n- GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择\n![image.png](https://upload-images.jianshu.io/upload_images/13449852-0a6c357a2b8c670d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n-  CallbackListener<Geodatabase>，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表[List](http://blog.csdn.net/arcgis_all/article/details/20442663)<[GdbFeatureTable](http://blog.csdn.net/arcgis_all/article/details/20442663)>对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。\n-  GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。\n-  GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。\n\n\n<br>\n## 4. 代码示例\n1. 在地图上自定义一个区域\n```\n     /**\n     * 绘制出在线缓存区域\n     * */\n    private void polygonState(Point currentPoint)throws Exception{\n        if(startPoint!=null&&!startPoint.isEmpty()){\n            polygon.lineTo(currentPoint);\n            currentGraphic = new Graphic(polygon, symbol);\n            drawLayer.updateGraphic(currentGraphicIndex,currentGraphic);\n\n            pointGraphic=new Graphic(multiPoint,pointSymbol);\n            drawLayer.updateGraphic(pointGraphicIndex,pointGraphic);\n            multiPoint.add(currentPoint);\n            if(lastGraphicIndex!=-1){\n                drawLayer.removeGraphic(lastGraphicIndex);\n            }\n            lastGraphic=new Graphic(currentPoint,lastSymbol);\n            lastGraphicIndex=drawLayer.addGraphic(lastGraphic);\n\n            if(polygon.getPointCount()>=3){\n                isCheckedSave=true;\n                isSave=isCheckedSave;\n                onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue));\n                onlinesave.setClickable(isSave);\n            }\n        }else{\n            polygon=new Polygon();\n            multiPoint=new MultiPoint();\n            polygon.startPath(currentPoint);\n            startPoint=currentPoint;\n            currentGraphic=new Graphic(startPoint,symbol);\n            currentGraphicIndex=drawLayer.addGraphic(currentGraphic);\n            pointGraphic=new Graphic(startPoint,lastSymbol);\n            pointGraphicIndex=drawLayer.addGraphic(pointGraphic);\n            multiPoint.add(currentPoint);\n        }\n    }\n    /**\n     * 确定所选区域范围\n     * */\n    public void SaveLabel()throws Exception{\n        if(isSave&&drawLayer!=null) {\n            startPoint = null;\n            isCheckedSave=false;\n            isSave=isCheckedSave;\n            onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n            onlinesave.setClickable(isSave);\n            if(currentGraphicIndex!=-1){\n                Graphic graphic = drawLayer.getGraphic(currentGraphicIndex);\n                if(graphic!=null){\n                    Geometry geometry=graphic.getGeometry();\n                    Graphic saveGraphic=null;\n                    if(geometryType.equals(Geometry.Type.POLYGON)){\n                        symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent));\n                        saveGraphic=new Graphic(geometry,symbol);\n                        pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                        pointGraphic=new Graphic(geometry,pointSymbol);\n                    }else{\n                        symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green));\n                        saveGraphic=new Graphic(geometry,symbol);\n                        pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);\n                        pointGraphic=new Graphic(geometry,pointSymbol);\n                    }\n                    if(onlineCacheInfoList!=null&&onlineCacheInfoList.size()>0){\n                        setView();\n                        int i = 0;\n                        if(onlineCacheInfoList.get(i).getCacheurl().trim().length()>0) {\n                            downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer\n                        }\n                    }\n                }\n            }\n        }else{\n            isCheckedSave=false;\n            isSave=isCheckedSave;\n            onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));\n            onlinesave.setClickable(isSave);\n        }\n    }\n```\n2. 下载选定区域所对应的在线缓存的文件\n```\nprivate void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) {\n        gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null);\n        gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener<FeatureServiceInfo>() {\n                    @Override\n                    public void onError(Throwable arg0) {\n                        Log.e(TAG, \"Error fetching FeatureServiceInfo\");\n                    }\n\n                    @Override\n                    public void onCallback(FeatureServiceInfo fsInfo) {\n                        if (fsInfo.isSyncEnabled()) {\n                           //回调获取所需要的下载的图层信息\n                            createGeodatabase(onlineCacheInfo.getIds(),geometry,i);\n                        }\n                    }\n                });\n\n    }\n    //创建下载\n    private void createGeodatabase(int[] ids, final Geometry geometry, final int i) {\n        SpatialReference sp=mOneMapView.getSpatialReference();\n        GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE);\n\n        CallbackListener<String> gdbResponseCallback = new CallbackListener<String>() {\n            @Override\n            public void onError(final Throwable e) {\n                Log.e(TAG, \"Error creating geodatabase\");\n                Toast.makeText(mActivity, \"数据下载失败!\", Toast.LENGTH_LONG).show();\n                pDialog.dismiss();\n            }\n\n            @Override\n            public void onCallback(String path) {\n                updateFeatureLayer(path);\n                if(i<onlineCacheInfoList.size()&&onlineCacheInfoList.get(i+1).getCacheurl().trim().length()>0){\n                    downloadData(onlineCacheInfoList.get(i+1),geometry,i+1);\n                }else {\n                    pDialog.dismiss();\n                    Toast.makeText(mActivity, \"数据下载完成!\", Toast.LENGTH_LONG).show();\n                }\n            }\n        };\n        localGdbFilePath = \"对应在本地存储的存储路径以及存储名称\";\n        submitTask(params, localGdbFilePath, statusCallback,\n                gdbResponseCallback);\n    }\n    private void submitTask(GenerateGeodatabaseParameters params,\n                            String file, GeodatabaseStatusCallback statusCallback,\n                            CallbackListener<String> gdbResponseCallback) {\n        // submit task\n        gdbSyncTask.generateGeodatabase(params, file, false, statusCallback,\n                gdbResponseCallback);\n    }\n```\n\n3. 将下载完成的数据再地图上展示\n\n```\n//加载数据\nprivate void updateFeatureLayer(String featureLayerPath) {\n        // create a new geodatabase\n        Geodatabase localGdb = null;\n        try {\n            localGdb = new Geodatabase(featureLayerPath);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        if (localGdb != null) {\n            for (GeodatabaseFeatureTable gdbFeatureTable : localGdb\n                    .getGeodatabaseTables()) {\n                if (gdbFeatureTable.hasGeometry()){\n                    mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable));\n                }\n            }\n        }\n    }\n```\n<br>\n## 5. 结语\n在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。\n\n\n- 最后感谢您的阅读，有机会一起探讨！\n","content":"<p><br></p>\n<h2 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h2><ol>\n<li>离线在线一体化<br>数据存储在企业级地理数据库中，通过Arcgis桌面加载后配图处理，并发布到Arcgis for Server中，供移动端设备编辑使用，并可以同步回传版本化存档。</li>\n<li>应用场景<br>在没有网络的情况下我们需要用到在线的地图数据进行操作，这些数据需要有一定的时效性，如果采用，打包离线包的方式提前做好离线数据，那时效性相对较差。所以，用在线缓存技术可以支持这一点。</li>\n</ol>\n<p><br></p>\n<h2 id=\"2-在线缓存的实现逻辑思路\"><a href=\"#2-在线缓存的实现逻辑思路\" class=\"headerlink\" title=\"2. 在线缓存的实现逻辑思路\"></a>2. 在线缓存的实现逻辑思路</h2><ul>\n<li>在地图上选定区域，作为需要下载对应离线数据的地图范围（可以设定范围，也可以自定义）</li>\n<li>获取下载滴地图服务所需要的具体参数</li>\n<li>在本地创建文件，存放下载的数据，以供使用</li>\n</ul>\n<p><br></p>\n<h2 id=\"3-用到的核心功能类以及说明\"><a href=\"#3-用到的核心功能类以及说明\" class=\"headerlink\" title=\"3. 用到的核心功能类以及说明\"></a>3. 用到的核心功能类以及说明</h2><ul>\n<li>GeodatabaseSyncTask类，实现下载同步功能</li>\n<li>GenerateGeodatabaseParameters，下载数据时所需的参数对象，该类构造函数一共有7个根据需要选择<br><img src=\"https://upload-images.jianshu.io/upload_images/13449852-0a6c357a2b8c670d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></li>\n<li>CallbackListener<geodatabase>，完成GDB数据库下载的回调函数类，在该回调中我们只可以执行一些操作，如示例里在回调中删除了在线的服务图层，加载离线的数据图层到地图上进行显示。通过Geodatabase本地数据库可以获取要素图层列表<a href=\"http://blog.csdn.net/arcgis_all/article/details/20442663\" target=\"_blank\" rel=\"noopener\">List</a>&lt;<a href=\"http://blog.csdn.net/arcgis_all/article/details/20442663\" target=\"_blank\" rel=\"noopener\">GdbFeatureTable</a>&gt;对象，通过newFeatureLayer(gdbFeatureTable)来创建一个离线要素图层进行要素显示。</geodatabase></li>\n<li>GeodatabaseStatusCallback，本地数据库回调状态类，在数据下载过程中会有很多状态改变，各种状态改变时都会走这个类的回调函数。</li>\n<li>GeodatabaseTask.generateGeodatabase，通过该方法生成离线数据库和相应的要素表，方法需要传递上面介绍的三个参数和一个数据库存储的路径。</li>\n</ul>\n<p><br></p>\n<h2 id=\"4-代码示例\"><a href=\"#4-代码示例\" class=\"headerlink\" title=\"4. 代码示例\"></a>4. 代码示例</h2><ol>\n<li><p>在地图上自定义一个区域</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> /**</span><br><span class=\"line\"> * 绘制出在线缓存区域</span><br><span class=\"line\"> * */</span><br><span class=\"line\">private void polygonState(Point currentPoint)throws Exception&#123;</span><br><span class=\"line\">    if(startPoint!=null&amp;&amp;!startPoint.isEmpty())&#123;</span><br><span class=\"line\">        polygon.lineTo(currentPoint);</span><br><span class=\"line\">        currentGraphic = new Graphic(polygon, symbol);</span><br><span class=\"line\">        drawLayer.updateGraphic(currentGraphicIndex,currentGraphic);</span><br><span class=\"line\"></span><br><span class=\"line\">        pointGraphic=new Graphic(multiPoint,pointSymbol);</span><br><span class=\"line\">        drawLayer.updateGraphic(pointGraphicIndex,pointGraphic);</span><br><span class=\"line\">        multiPoint.add(currentPoint);</span><br><span class=\"line\">        if(lastGraphicIndex!=-1)&#123;</span><br><span class=\"line\">            drawLayer.removeGraphic(lastGraphicIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        lastGraphic=new Graphic(currentPoint,lastSymbol);</span><br><span class=\"line\">        lastGraphicIndex=drawLayer.addGraphic(lastGraphic);</span><br><span class=\"line\"></span><br><span class=\"line\">        if(polygon.getPointCount()&gt;=3)&#123;</span><br><span class=\"line\">            isCheckedSave=true;</span><br><span class=\"line\">            isSave=isCheckedSave;</span><br><span class=\"line\">            onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.blue));</span><br><span class=\"line\">            onlinesave.setClickable(isSave);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        polygon=new Polygon();</span><br><span class=\"line\">        multiPoint=new MultiPoint();</span><br><span class=\"line\">        polygon.startPath(currentPoint);</span><br><span class=\"line\">        startPoint=currentPoint;</span><br><span class=\"line\">        currentGraphic=new Graphic(startPoint,symbol);</span><br><span class=\"line\">        currentGraphicIndex=drawLayer.addGraphic(currentGraphic);</span><br><span class=\"line\">        pointGraphic=new Graphic(startPoint,lastSymbol);</span><br><span class=\"line\">        pointGraphicIndex=drawLayer.addGraphic(pointGraphic);</span><br><span class=\"line\">        multiPoint.add(currentPoint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 确定所选区域范围</span><br><span class=\"line\"> * */</span><br><span class=\"line\">public void SaveLabel()throws Exception&#123;</span><br><span class=\"line\">    if(isSave&amp;&amp;drawLayer!=null) &#123;</span><br><span class=\"line\">        startPoint = null;</span><br><span class=\"line\">        isCheckedSave=false;</span><br><span class=\"line\">        isSave=isCheckedSave;</span><br><span class=\"line\">        onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));</span><br><span class=\"line\">        onlinesave.setClickable(isSave);</span><br><span class=\"line\">        if(currentGraphicIndex!=-1)&#123;</span><br><span class=\"line\">            Graphic graphic = drawLayer.getGraphic(currentGraphicIndex);</span><br><span class=\"line\">            if(graphic!=null)&#123;</span><br><span class=\"line\">                Geometry geometry=graphic.getGeometry();</span><br><span class=\"line\">                Graphic saveGraphic=null;</span><br><span class=\"line\">                if(geometryType.equals(Geometry.Type.POLYGON))&#123;</span><br><span class=\"line\">                    symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green_transparent));</span><br><span class=\"line\">                    saveGraphic=new Graphic(geometry,symbol);</span><br><span class=\"line\">                    pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);</span><br><span class=\"line\">                    pointGraphic=new Graphic(geometry,pointSymbol);</span><br><span class=\"line\">                &#125;else&#123;</span><br><span class=\"line\">                    symbol=MapViewTapTool.getLabelSymbol(mActivity,geometryType,ContextCompat.getColor(mActivity,R.color.green));</span><br><span class=\"line\">                    saveGraphic=new Graphic(geometry,symbol);</span><br><span class=\"line\">                    pointSymbol=MapViewTapTool.getCircleGreenSymbol(mActivity);</span><br><span class=\"line\">                    pointGraphic=new Graphic(geometry,pointSymbol);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                if(onlineCacheInfoList!=null&amp;&amp;onlineCacheInfoList.size()&gt;0)&#123;</span><br><span class=\"line\">                    setView();</span><br><span class=\"line\">                    int i = 0;</span><br><span class=\"line\">                    if(onlineCacheInfoList.get(i).getCacheurl().trim().length()&gt;0) &#123;</span><br><span class=\"line\">                        downloadData(onlineCacheInfoList.get(i), geometry, i);//缓存featureLayer</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        isCheckedSave=false;</span><br><span class=\"line\">        isSave=isCheckedSave;</span><br><span class=\"line\">        onlinesave.setTextColor(ContextCompat.getColor(mActivity,R.color.gray));</span><br><span class=\"line\">        onlinesave.setClickable(isSave);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>下载选定区域所对应的在线缓存的文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private void downloadData(final OnlineCacheInfo onlineCacheInfo, final Geometry geometry, final int i) &#123;</span><br><span class=\"line\">        gdbSyncTask = new GeodatabaseSyncTask(onlineCacheInfo.getCacheurl(), null);</span><br><span class=\"line\">        gdbSyncTask.fetchFeatureServiceInfo(new CallbackListener&lt;FeatureServiceInfo&gt;() &#123;</span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onError(Throwable arg0) &#123;</span><br><span class=\"line\">                        Log.e(TAG, &quot;Error fetching FeatureServiceInfo&quot;);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    @Override</span><br><span class=\"line\">                    public void onCallback(FeatureServiceInfo fsInfo) &#123;</span><br><span class=\"line\">                        if (fsInfo.isSyncEnabled()) &#123;</span><br><span class=\"line\">                           //回调获取所需要的下载的图层信息</span><br><span class=\"line\">                            createGeodatabase(onlineCacheInfo.getIds(),geometry,i);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //创建下载</span><br><span class=\"line\">    private void createGeodatabase(int[] ids, final Geometry geometry, final int i) &#123;</span><br><span class=\"line\">        SpatialReference sp=mOneMapView.getSpatialReference();</span><br><span class=\"line\">        GenerateGeodatabaseParameters params = new GenerateGeodatabaseParameters(ids, geometry,sp,true, SyncModel.GEODATABASE);</span><br><span class=\"line\"></span><br><span class=\"line\">        CallbackListener&lt;String&gt; gdbResponseCallback = new CallbackListener&lt;String&gt;() &#123;</span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onError(final Throwable e) &#123;</span><br><span class=\"line\">                Log.e(TAG, &quot;Error creating geodatabase&quot;);</span><br><span class=\"line\">                Toast.makeText(mActivity, &quot;数据下载失败!&quot;, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                pDialog.dismiss();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            @Override</span><br><span class=\"line\">            public void onCallback(String path) &#123;</span><br><span class=\"line\">                updateFeatureLayer(path);</span><br><span class=\"line\">                if(i&lt;onlineCacheInfoList.size()&amp;&amp;onlineCacheInfoList.get(i+1).getCacheurl().trim().length()&gt;0)&#123;</span><br><span class=\"line\">                    downloadData(onlineCacheInfoList.get(i+1),geometry,i+1);</span><br><span class=\"line\">                &#125;else &#123;</span><br><span class=\"line\">                    pDialog.dismiss();</span><br><span class=\"line\">                    Toast.makeText(mActivity, &quot;数据下载完成!&quot;, Toast.LENGTH_LONG).show();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        localGdbFilePath = &quot;对应在本地存储的存储路径以及存储名称&quot;;</span><br><span class=\"line\">        submitTask(params, localGdbFilePath, statusCallback,</span><br><span class=\"line\">                gdbResponseCallback);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    private void submitTask(GenerateGeodatabaseParameters params,</span><br><span class=\"line\">                            String file, GeodatabaseStatusCallback statusCallback,</span><br><span class=\"line\">                            CallbackListener&lt;String&gt; gdbResponseCallback) &#123;</span><br><span class=\"line\">        // submit task</span><br><span class=\"line\">        gdbSyncTask.generateGeodatabase(params, file, false, statusCallback,</span><br><span class=\"line\">                gdbResponseCallback);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将下载完成的数据再地图上展示</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//加载数据</span><br><span class=\"line\">private void updateFeatureLayer(String featureLayerPath) &#123;</span><br><span class=\"line\">        // create a new geodatabase</span><br><span class=\"line\">        Geodatabase localGdb = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            localGdb = new Geodatabase(featureLayerPath);</span><br><span class=\"line\">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        if (localGdb != null) &#123;</span><br><span class=\"line\">            for (GeodatabaseFeatureTable gdbFeatureTable : localGdb</span><br><span class=\"line\">                    .getGeodatabaseTables()) &#123;</span><br><span class=\"line\">                if (gdbFeatureTable.hasGeometry())&#123;</span><br><span class=\"line\">                    mOneMapView.addLayer(new FeatureLayer(gdbFeatureTable));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h2 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5. 结语\"></a>5. 结语</h2><p>在线缓存的应用，减少了手动制作离线数据的步骤，大大提高了地图制作的效率，只需发布对应的地图服务就能实现离线数据的在线下载。另外也同时保证了数据的时效性，如果对应地图服务有新的数据更改，那我们可以重新下载新的在线数据，不需要再去手动打包地图文件。</p>\n<ul>\n<li>最后感谢您的阅读，有机会一起探讨！</li>\n</ul>\n","slug":"在线缓存功能开发分享-万峥嵘","updated":"2018-09-28T08:15:59.152Z","comments":true,"link":"","permalink":"http://yoursite.com/2018/08/05/在线缓存功能开发分享-万峥嵘/","excerpt":"","categories":[{"name":"万峥嵘","slug":"万峥嵘","permalink":"http://yoursite.com/categories/万峥嵘/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Jenkins For Ios","date":"2017-02-24T01:36:24.000Z","path":"2017/02/24/20170224-Jenkins for iOS-刘小标/","text":"Jenkins for iOS with Fastlane and SVN 一、搭建环境Jenkins的安装需要JDK环境，JDK安装方法自行参考网络。Jenkins的安装有两种方式，一种是java包安装，另一种是pkg可执行程序（两种安装后的配置一样，pkg安装会在电脑上多出一个用户）。本文采用war包 + tomcat安装方法。 1 安装Java环境，请自行下载安装 2 安装tomcat,打开官网地址 2.1 将下载的zip包解压（可以重命名），把解压后的文件夹放到 /Library下。 2.2 在终端启动Tomcat服务器，这里首先cd到Tomcat的bin目录：sudo chmod 755 *.sh按回车键之后会提示输入密码，请输入管理员密码。之后输入并回车:sudo sh startup.sh执行完startup.sh的结果如下: 然后在浏览器里输入：localhost:8080就OK了。如下图所示: 二、Jenkins安装，打开官网 在tomcat的安装目录下，找到webapps，然后将下载的war包放到该文件夹下即可。在浏览器里输入：localhost:8080/Jenkins/，几分钟后即可以看到如下界面： 根据自己安装的红色提示，前往该文件打开，找到初始密码。（pkg安装模式，会提示没有打开文件夹权限，则需要你手动获取对应的读写权限）接下来则是傻瓜式操作。如下图所示： 设置用户名密码邮件等，最后Save and Finish，OK，到此Jenkins初始化安装完成。 1 安装系统插件在“系统管理-&gt;管理插件-&gt;可选插件”中，选择下载必要的插件。1、 Publish Over FTP Plugin2、 Email Extension Plugin 2 系统配置2.1 在“系统管理-&gt;系统设置”中找到“Jenkins Location”配置，配置如下图： 2.2 在“系统管理-&gt;系统设置”中找到“Publish over FTP”配置，配置如下图： 2.3 在“系统管理-&gt;系统设置”中找到“Extended E-mail Notification”配置，配置如下图： Default Content样例：(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt; 项目名称：$PROJECT_NAME&lt;br/&gt;&lt;hr/&gt; 版本号：${FILE,path=&quot;version.txt&quot;}&lt;br/&gt;&lt;hr/&gt; svn版本号：${SVN_REVISION}&lt;br/&gt;&lt;hr/&gt; 构建状态：$BUILD_STATUS&lt;br/&gt;&lt;hr/&gt; 触发原因：${CAUSE}&lt;br/&gt;&lt;hr/&gt; 构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt; 变更集:${JELLY_SCRIPT,template=&quot;html&quot;}&lt;br/&gt;&lt;hr/&gt; 三、Fastlane安装1 安装ruby版本&gt;=2.21.1 安装rvm版本管理器$ curl -L https://get.rvm.io | bash -s stable 1.2 等待一段时间后， 使用一下命令进行验证$ source ~/.bashrc $ source ~/.bash_profile 1.3 测试是否安装正常$ rvm -v 如果出现rvm（版本号）…..基本就算是安装RVM成功了。补充一些常用命令： rvm list 查看已安装ruby rvm list known 列出ruby可安装版本信息 rvm remove 2.2.2 卸载一个已安装的ruby版本 gem source 查看已有源 gem sources -a http://ruby.taobao.org把源切换至淘宝镜像服务器 1.4 安装ruby$ rvm install 2.4 2 安装fastlane，详细资料请看Github地址2.1 命令安装$ sudo gem install fastlane 2.2 查看版本$ fastlane –v 2.3 查看命令方法$ fastlane actions 2.4 查看指定方法$ fastlane actions gym 四、Jenkins新建Job1 新建一个item，选择自由风格的项目 2 输入项目名称，描述等基本信息。 3 源代码管理，因为使用的是SVN，所以选择Subversion。具体操作如下图所示：点击Add配置SVN用户信息。如下图所示：成功配置如下图所示： 4 配置构建触发器4.1触发器支持多种类型，常用的有：A 定期进行构建（Build periodically） B 根据提交进行构建（Build when a change is pushed to GitHub） C 定期检测代码更新，如有更新则进行构建（Poll SCM） 构建触发器的选择为复合选项，若选择多种类型，则任一类型满足构建条件时就会执行构建工作。 关于定时器（Schedule）的格式，简述如下：MINUTE HOUR DOM MONTH DOW • MINUTE: Minutes within the hour (0-59) • HOUR: The hour of the day (0-23) • DOM: The day of the month (1-31) • MONTH: The month (1-12) • DOW: The day of the week (0-7) where 0 and 7 are Sunday. 通常情况下需要指定多个值，这时可以采用如下operator（优先级从上到下）： • *适配所有有效的值，若不指定某一项，则以*占位； • M-N适配值域范围，例如7-9代表7/8/9均满足； • M-N/X或*/X：以X作为间隔； • A,B,C：枚举多个值。 另外，为了避免多个任务在同一时刻同时触发构建，在指定时间段时可以配合使用H字符。添加H字符后，Jenkins会在指定时间段内随机选择一个时间点作为起始时刻，然后加上设定的时间间隔，计算得到后续的时间点。直到下一个周期时，Jenkins又会重新随机选择一个时间点作为起始时刻，依次类推。 为了便于理解，列举几个示例： • H/15 * * * *：代表每隔15分钟，并且开始时间不确定，这个小时可能是:07,:22,:37,:52，下一个小时就可能是:03,:18,:33,:48； • H(0-29)/10 * * * *：代表前半小时内每隔10分钟，并且开始时间不确定，这个小时可能是:04,:14,:24，下一个小时就可能是:09,:19,:29； • H 23 * * 1-5：工作日每晚23:00至23:59之间的某一时刻； 5 构建环境（没有用到，暂未深入研究） 6 构建选择Execute shell Execute shell代码段#!/bin/bash #计时 SECONDS=0 #假设脚本放置在与项目相同的路径下 project_path=$(pwd) # 创建build路径 build_path=${project_path}/build # 清空并建立路径 if [ -d ${build_path} ];then rm -rf ${build_path}; fi; mkdir ${build_path}; #取当前时间字符串添加到文件结尾 now=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;) #指定项目的scheme名称 scheme=$(ls | grep xcodeproj | awk -F.xcodeproj &apos;{print $1}&apos;) #指定要打包的配置名 configuration=&quot;Release&quot; #指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数 export_method=&apos;enterprise&apos; #info.plist路径 project_infoplist_path=&quot;$project_path/${scheme}/Info.plist&quot; #获取版本号 bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;${project_infoplist_path}&quot;) #清空并记录当前编译版本号 echo &gt; version.txt echo &quot;${bundleShortVersion}&quot;&gt;&gt; version.txt #指定项目地址 workspace_path=&quot;$project_path/${scheme}.xcworkspace&quot; #指定输出路径 output_path=${build_path} #指定输出归档文件地址 archive_path=&quot;$output_path/${scheme}_${now}.xcarchive&quot; #指定输出ipa地址 ipa_path=&quot;$output_path/${scheme}_${now}.ipa&quot; #指定输出ipa名称 ipa_name=&quot;${scheme}.ipa&quot; #获取执行命令时的commit message commit_msg=&quot;$1&quot; #输出设定的变量值 echo &quot;===workspace path: ${workspace_path}===&quot; echo &quot;===archive path: ${archive_path}===&quot; echo &quot;===ipa path: ${ipa_path}===&quot; echo &quot;===export method: ${export_method}===&quot; echo &quot;===commit msg: $1===&quot; #先清空前一次build fastlane gym --workspace ${workspace_path} --scheme ${scheme} --clean --configuration ${configuration} --archive_path ${archive_path} --export_method ${export_method} --output_directory ${output_path} --output_name ${ipa_name} #输出总用时 echo &quot;===Finished. Total time: ${SECONDS}s===&quot; 7 构建后操作增加邮件提醒，选择Editable Email Notification配置触发操作： 8 构建后操作增加文件上传，选择Send build artifacts over FTP 至此，Jenkins的安装配置完成，立即构建查看效果吧。","raw":"---\ntitle: Jenkins For Ios\ndate: 2017-02-24 09:36:24\ntags: IOS\ncategories: 刘小标\n---\n\n#\tJenkins for iOS with Fastlane and SVN\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/1.png)\n##    一、搭建环境\nJenkins的安装需要JDK环境，JDK安装方法自行参考网络。Jenkins的安装有两种方式，一种是java包安装，另一种是pkg可执行程序（两种安装后的配置一样，pkg安装会在电脑上多出一个用户）。本文采用war包 + tomcat安装方法。\n###\t1   安装[Java](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)环境，请自行下载安装\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/2.png)\n###\t2   安装[tomcat](https://tomcat.apache.org/),打开官网地址\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/3.png)\n####\t2.1    将下载的zip包解压（可以重命名），把解压后的文件夹放到 /Library下。\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/4.png)\n####\t2.2    在终端启动Tomcat服务器，这里首先cd到Tomcat的bin目录：   \n`sudo chmod 755 *.sh`<br>\n按回车键之后会提示输入密码，请输入管理员密码。之后输入并回车:<br>\n`sudo sh startup.sh`<br>\n执行完`startup.sh`的结果如下:\n\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/5.png)\n\n然后在浏览器里输入：`localhost:8080`就OK了。如下图所示:\n\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/6.png)\n\n##    二、Jenkins安装，打开[官网](https://jenkins.io/index.html)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/7.png)\n\n在tomcat的安装目录下，找到`webapps`，然后将下载的`war`包放到该文件夹下即可。\n在浏览器里输入：`localhost:8080/Jenkins/`，几分钟后即可以看到如下界面：\n\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/8.png)\n\n根据自己安装的红色提示，前往该文件打开，找到初始密码。（pkg安装模式，会提示没有打开文件夹权限，则需要你手动获取对应的读写权限）\n接下来则是傻瓜式操作。如下图所示：\n\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/9.png)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/10.png)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/11.png)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/12.png)\n\n设置用户名密码邮件等，最后Save and Finish，OK，到此Jenkins初始化安装完成。\n\n###   1   安装系统插件\n在“系统管理->管理插件->可选插件”中，选择下载必要的插件。<br>\n1、\tPublish Over FTP Plugin<br>\n2、\tEmail Extension Plugin<br>\n###   2   系统配置\n####   2.1   在“系统管理->系统设置”中找到“Jenkins Location”配置，配置如下图：\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/13.png)\n####   2.2   在“系统管理->系统设置”中找到“Publish over FTP”配置，配置如下图：\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/14.png)\n####   2.3   在“系统管理->系统设置”中找到“Extended E-mail Notification”配置，配置如下图：\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/15.png)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/16.png)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/17.png)\n\n####   Default Content样例：\n\t(本邮件是程序自动下发的，请勿回复！)<br/><hr/>\n\t项目名称：$PROJECT_NAME<br/><hr/>\n\t版本号：${FILE,path=\"version.txt\"}<br/><hr/>\n\tsvn版本号：${SVN_REVISION}<br/><hr/>\n\t构建状态：$BUILD_STATUS<br/><hr/>\n\t触发原因：${CAUSE}<br/><hr/>\n\t构建日志地址：<a href=\"${BUILD_URL}console\">${BUILD_URL}console</a><br/><hr/>\n\t变更集:${JELLY_SCRIPT,template=\"html\"}<br/><hr/>\n\n##    三、Fastlane安装\n###   1   安装ruby版本>=2.2\n####    1.1   安装rvm版本管理器\n\t$ curl -L https://get.rvm.io | bash -s stable\n####    1.2   等待一段时间后， 使用一下命令进行验证\n\t$ source ~/.bashrc\n\t$ source ~/.bash_profile\n####    1.3   测试是否安装正常\n\t$ rvm -v\n如果出现rvm（版本号）.....基本就算是安装RVM成功了。<br>\n补充一些常用命令：<br>\n\t\n\trvm list 查看已安装ruby\n\trvm list known 列出ruby可安装版本信息\n\trvm remove 2.2.2 卸载一个已安装的ruby版本\n\tgem source 查看已有源\n\tgem sources -a http://ruby.taobao.org把源切换至淘宝镜像服务器\n####    1.4   安装ruby\n\t$ rvm install 2.4\n\t\n###   2   安装fastlane，详细资料请看[Github地址](https://github.com/fastlane/fastlane)\n\n####    2.1   命令安装\n\t$ sudo gem install fastlane\n\t\n####    2.2   查看版本\n\t$ fastlane –v\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/18.png)\n\n####    2.3   查看命令方法\n\t$ fastlane actions\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/19.png)\n\n####    2.4   查看指定方法\n\t$ fastlane actions gym\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/20.png)\n\n##\t四、Jenkins新建Job\n\n###\t1\t新建一个item，选择自由风格的项目\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/21.png)\n\n###\t2\t输入项目名称，描述等基本信息。\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/22.png)\n\n###\t3 源代码管理，因为使用的是SVN，所以选择Subversion。具体操作如下图所示：\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/23.png)\n点击Add配置SVN用户信息。如下图所示：\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/24.png)\n成功配置如下图所示：\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/25.png)\n\n###\t4\t配置构建触发器\n####\t4.1触发器支持多种类型，常用的有：\n\t\n\tA 定期进行构建（Build periodically）\n\tB 根据提交进行构建（Build when a change is pushed to GitHub）\n\tC 定期检测代码更新，如有更新则进行构建（Poll SCM）\n\t\n构建触发器的选择为复合选项，若选择多种类型，则任一类型满足构建条件时就会执行构建工作。\n\n关于定时器（Schedule）的格式，简述如下：MINUTE HOUR DOM MONTH DOW\n\t\n\t•  MINUTE: Minutes within the hour (0-59)\n\t•  HOUR: The hour of the day (0-23)\n\t•  DOM: The day of the month (1-31)\n\t•  MONTH: The month (1-12)\n\t•  DOW: The day of the week (0-7) where 0 and 7 are Sunday.\n\n通常情况下需要指定多个值，这时可以采用如下operator（优先级从上到下）：\n\t\n\t•  *适配所有有效的值，若不指定某一项，则以*占位；\n\t•  M-N适配值域范围，例如7-9代表7/8/9均满足；\n\t•  M-N/X或*/X：以X作为间隔；\n\t•  A,B,C：枚举多个值。\n另外，为了避免多个任务在同一时刻同时触发构建，在指定时间段时可以配合使用H字符。添加H字符后，Jenkins会在指定时间段内随机选择一个时间点作为起始时刻，然后加上设定的时间间隔，计算得到后续的时间点。直到下一个周期时，Jenkins又会重新随机选择一个时间点作为起始时刻，依次类推。\n\n为了便于理解，列举几个示例：\n\t\n\t•  H/15 * * * *：代表每隔15分钟，并且开始时间不确定，这个小时可能是:07,:22,:37,:52，下一个小时就可能是:03,:18,:33,:48；\n\t•  H(0-29)/10 * * * *：代表前半小时内每隔10分钟，并且开始时间不确定，这个小时可能是:04,:14,:24，下一个小时就可能是:09,:19,:29；\n\t•  H 23 * * 1-5：工作日每晚23:00至23:59之间的某一时刻；\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/26.png)\t\n\n###\t5\t构建环境（没有用到，暂未深入研究）\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/27.png)\n\n###\t6\t构建选择Execute shell\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/28.png)\n\n####\tExecute shell代码段\n\t\n\t#!/bin/bash\n\t#计时\n\tSECONDS=0\n\t#假设脚本放置在与项目相同的路径下\n\tproject_path=$(pwd)\n\t# 创建build路径\n\tbuild_path=${project_path}/build\n\t# 清空并建立路径\n\tif [ -d ${build_path} ];then\n\trm -rf ${build_path}; fi;\n\tmkdir ${build_path};\n\n\t#取当前时间字符串添加到文件结尾\n\tnow=$(date +\"%Y_%m_%d_%H_%M_%S\")\n\n\t#指定项目的scheme名称\n\tscheme=$(ls | grep xcodeproj | awk -F.xcodeproj '{print $1}')\n\t#指定要打包的配置名\n\tconfiguration=\"Release\"\n\t#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数\n\texport_method='enterprise'\n\n\t#info.plist路径\n\tproject_infoplist_path=\"$project_path/${scheme}/Info.plist\"\n\t#获取版本号\n\tbundleShortVersion=$(/usr/libexec/PlistBuddy -c \"print CFBundleShortVersionString\" \"${project_infoplist_path}\")\n\t#清空并记录当前编译版本号\n\techo > version.txt\n\techo \"${bundleShortVersion}\">> version.txt\n\n\t#指定项目地址\n\tworkspace_path=\"$project_path/${scheme}.xcworkspace\"\n\t#指定输出路径\n\toutput_path=${build_path}\n\t#指定输出归档文件地址\n\tarchive_path=\"$output_path/${scheme}_${now}.xcarchive\"\n\t#指定输出ipa地址\n\tipa_path=\"$output_path/${scheme}_${now}.ipa\"\n\t#指定输出ipa名称\n\tipa_name=\"${scheme}.ipa\"\n\t#获取执行命令时的commit message\n\tcommit_msg=\"$1\"\n\n\t#输出设定的变量值\n\techo \"===workspace path: ${workspace_path}===\"\n\techo \"===archive path: ${archive_path}===\"\n\techo \"===ipa path: ${ipa_path}===\"\n\techo \"===export method: ${export_method}===\"\n\techo \"===commit msg: $1===\"\n\n\t#先清空前一次build\n\tfastlane gym --workspace ${workspace_path} --scheme ${scheme} --clean --configuration ${configuration} --archive_path \t${archive_path} --export_method ${export_method} --output_directory ${output_path} --output_name ${ipa_name}\n\n\t#输出总用时\n\techo \"===Finished. Total time: ${SECONDS}s===\"\n\n###\t7\t构建后操作增加邮件提醒，选择Editable Email Notification\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/29.png)\n配置触发操作：\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/30.png)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/31.png)\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/32.png)\n\n###\t8\t构建后操作增加文件上传，选择Send build artifacts over FTP\n![image](https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/33.png)\n\n\n# 至此，Jenkins的安装配置完成，立即构建查看效果吧。\n","content":"<h1 id=\"Jenkins-for-iOS-with-Fastlane-and-SVN\"><a href=\"#Jenkins-for-iOS-with-Fastlane-and-SVN\" class=\"headerlink\" title=\"Jenkins for iOS with Fastlane and SVN\"></a>Jenkins for iOS with Fastlane and SVN</h1><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/1.png\" alt=\"image\"></p>\n<h2 id=\"一、搭建环境\"><a href=\"#一、搭建环境\" class=\"headerlink\" title=\"一、搭建环境\"></a>一、搭建环境</h2><p>Jenkins的安装需要JDK环境，JDK安装方法自行参考网络。Jenkins的安装有两种方式，一种是java包安装，另一种是pkg可执行程序（两种安装后的配置一样，pkg安装会在电脑上多出一个用户）。本文采用war包 + tomcat安装方法。</p>\n<h3 id=\"1-安装Java环境，请自行下载安装\"><a href=\"#1-安装Java环境，请自行下载安装\" class=\"headerlink\" title=\"1   安装Java环境，请自行下载安装\"></a>1   安装<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html\" target=\"_blank\" rel=\"noopener\">Java</a>环境，请自行下载安装</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/2.png\" alt=\"image\"></p>\n<h3 id=\"2-安装tomcat-打开官网地址\"><a href=\"#2-安装tomcat-打开官网地址\" class=\"headerlink\" title=\"2   安装tomcat,打开官网地址\"></a>2   安装<a href=\"https://tomcat.apache.org/\" target=\"_blank\" rel=\"noopener\">tomcat</a>,打开官网地址</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/3.png\" alt=\"image\"></p>\n<h4 id=\"2-1-将下载的zip包解压（可以重命名），把解压后的文件夹放到-Library下。\"><a href=\"#2-1-将下载的zip包解压（可以重命名），把解压后的文件夹放到-Library下。\" class=\"headerlink\" title=\"2.1    将下载的zip包解压（可以重命名），把解压后的文件夹放到 /Library下。\"></a>2.1    将下载的zip包解压（可以重命名），把解压后的文件夹放到 /Library下。</h4><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/4.png\" alt=\"image\"></p>\n<h4 id=\"2-2-在终端启动Tomcat服务器，这里首先cd到Tomcat的bin目录：\"><a href=\"#2-2-在终端启动Tomcat服务器，这里首先cd到Tomcat的bin目录：\" class=\"headerlink\" title=\"2.2    在终端启动Tomcat服务器，这里首先cd到Tomcat的bin目录：\"></a>2.2    在终端启动Tomcat服务器，这里首先cd到Tomcat的bin目录：</h4><p><code>sudo chmod 755 *.sh</code><br><br>按回车键之后会提示输入密码，请输入管理员密码。之后输入并回车:<br><br><code>sudo sh startup.sh</code><br><br>执行完<code>startup.sh</code>的结果如下:</p>\n<p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/5.png\" alt=\"image\"></p>\n<p>然后在浏览器里输入：<code>localhost:8080</code>就OK了。如下图所示:</p>\n<p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/6.png\" alt=\"image\"></p>\n<h2 id=\"二、Jenkins安装，打开官网\"><a href=\"#二、Jenkins安装，打开官网\" class=\"headerlink\" title=\"二、Jenkins安装，打开官网\"></a>二、Jenkins安装，打开<a href=\"https://jenkins.io/index.html\" target=\"_blank\" rel=\"noopener\">官网</a></h2><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/7.png\" alt=\"image\"></p>\n<p>在tomcat的安装目录下，找到<code>webapps</code>，然后将下载的<code>war</code>包放到该文件夹下即可。<br>在浏览器里输入：<code>localhost:8080/Jenkins/</code>，几分钟后即可以看到如下界面：</p>\n<p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/8.png\" alt=\"image\"></p>\n<p>根据自己安装的红色提示，前往该文件打开，找到初始密码。（pkg安装模式，会提示没有打开文件夹权限，则需要你手动获取对应的读写权限）<br>接下来则是傻瓜式操作。如下图所示：</p>\n<p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/9.png\" alt=\"image\"><br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/10.png\" alt=\"image\"><br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/11.png\" alt=\"image\"><br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/12.png\" alt=\"image\"></p>\n<p>设置用户名密码邮件等，最后Save and Finish，OK，到此Jenkins初始化安装完成。</p>\n<h3 id=\"1-安装系统插件\"><a href=\"#1-安装系统插件\" class=\"headerlink\" title=\"1   安装系统插件\"></a>1   安装系统插件</h3><p>在“系统管理-&gt;管理插件-&gt;可选插件”中，选择下载必要的插件。<br><br>1、    Publish Over FTP Plugin<br><br>2、    Email Extension Plugin<br></p>\n<h3 id=\"2-系统配置\"><a href=\"#2-系统配置\" class=\"headerlink\" title=\"2   系统配置\"></a>2   系统配置</h3><h4 id=\"2-1-在“系统管理-gt-系统设置”中找到“Jenkins-Location”配置，配置如下图：\"><a href=\"#2-1-在“系统管理-gt-系统设置”中找到“Jenkins-Location”配置，配置如下图：\" class=\"headerlink\" title=\"2.1   在“系统管理-&gt;系统设置”中找到“Jenkins Location”配置，配置如下图：\"></a>2.1   在“系统管理-&gt;系统设置”中找到“Jenkins Location”配置，配置如下图：</h4><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/13.png\" alt=\"image\"></p>\n<h4 id=\"2-2-在“系统管理-gt-系统设置”中找到“Publish-over-FTP”配置，配置如下图：\"><a href=\"#2-2-在“系统管理-gt-系统设置”中找到“Publish-over-FTP”配置，配置如下图：\" class=\"headerlink\" title=\"2.2   在“系统管理-&gt;系统设置”中找到“Publish over FTP”配置，配置如下图：\"></a>2.2   在“系统管理-&gt;系统设置”中找到“Publish over FTP”配置，配置如下图：</h4><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/14.png\" alt=\"image\"></p>\n<h4 id=\"2-3-在“系统管理-gt-系统设置”中找到“Extended-E-mail-Notification”配置，配置如下图：\"><a href=\"#2-3-在“系统管理-gt-系统设置”中找到“Extended-E-mail-Notification”配置，配置如下图：\" class=\"headerlink\" title=\"2.3   在“系统管理-&gt;系统设置”中找到“Extended E-mail Notification”配置，配置如下图：\"></a>2.3   在“系统管理-&gt;系统设置”中找到“Extended E-mail Notification”配置，配置如下图：</h4><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/15.png\" alt=\"image\"><br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/16.png\" alt=\"image\"><br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/17.png\" alt=\"image\"></p>\n<h4 id=\"Default-Content样例：\"><a href=\"#Default-Content样例：\" class=\"headerlink\" title=\"Default Content样例：\"></a>Default Content样例：</h4><pre><code>(本邮件是程序自动下发的，请勿回复！)&lt;br/&gt;&lt;hr/&gt;\n项目名称：$PROJECT_NAME&lt;br/&gt;&lt;hr/&gt;\n版本号：${FILE,path=&quot;version.txt&quot;}&lt;br/&gt;&lt;hr/&gt;\nsvn版本号：${SVN_REVISION}&lt;br/&gt;&lt;hr/&gt;\n构建状态：$BUILD_STATUS&lt;br/&gt;&lt;hr/&gt;\n触发原因：${CAUSE}&lt;br/&gt;&lt;hr/&gt;\n构建日志地址：&lt;a href=&quot;${BUILD_URL}console&quot;&gt;${BUILD_URL}console&lt;/a&gt;&lt;br/&gt;&lt;hr/&gt;\n变更集:${JELLY_SCRIPT,template=&quot;html&quot;}&lt;br/&gt;&lt;hr/&gt;\n</code></pre><h2 id=\"三、Fastlane安装\"><a href=\"#三、Fastlane安装\" class=\"headerlink\" title=\"三、Fastlane安装\"></a>三、Fastlane安装</h2><h3 id=\"1-安装ruby版本-gt-2-2\"><a href=\"#1-安装ruby版本-gt-2-2\" class=\"headerlink\" title=\"1   安装ruby版本&gt;=2.2\"></a>1   安装ruby版本&gt;=2.2</h3><h4 id=\"1-1-安装rvm版本管理器\"><a href=\"#1-1-安装rvm版本管理器\" class=\"headerlink\" title=\"1.1   安装rvm版本管理器\"></a>1.1   安装rvm版本管理器</h4><pre><code>$ curl -L https://get.rvm.io | bash -s stable\n</code></pre><h4 id=\"1-2-等待一段时间后，-使用一下命令进行验证\"><a href=\"#1-2-等待一段时间后，-使用一下命令进行验证\" class=\"headerlink\" title=\"1.2   等待一段时间后， 使用一下命令进行验证\"></a>1.2   等待一段时间后， 使用一下命令进行验证</h4><pre><code>$ source ~/.bashrc\n$ source ~/.bash_profile\n</code></pre><h4 id=\"1-3-测试是否安装正常\"><a href=\"#1-3-测试是否安装正常\" class=\"headerlink\" title=\"1.3   测试是否安装正常\"></a>1.3   测试是否安装正常</h4><pre><code>$ rvm -v\n</code></pre><p>如果出现rvm（版本号）…..基本就算是安装RVM成功了。<br><br>补充一些常用命令：<br></p>\n<pre><code>rvm list 查看已安装ruby\nrvm list known 列出ruby可安装版本信息\nrvm remove 2.2.2 卸载一个已安装的ruby版本\ngem source 查看已有源\ngem sources -a http://ruby.taobao.org把源切换至淘宝镜像服务器\n</code></pre><h4 id=\"1-4-安装ruby\"><a href=\"#1-4-安装ruby\" class=\"headerlink\" title=\"1.4   安装ruby\"></a>1.4   安装ruby</h4><pre><code>$ rvm install 2.4\n</code></pre><h3 id=\"2-安装fastlane，详细资料请看Github地址\"><a href=\"#2-安装fastlane，详细资料请看Github地址\" class=\"headerlink\" title=\"2   安装fastlane，详细资料请看Github地址\"></a>2   安装fastlane，详细资料请看<a href=\"https://github.com/fastlane/fastlane\" target=\"_blank\" rel=\"noopener\">Github地址</a></h3><h4 id=\"2-1-命令安装\"><a href=\"#2-1-命令安装\" class=\"headerlink\" title=\"2.1   命令安装\"></a>2.1   命令安装</h4><pre><code>$ sudo gem install fastlane\n</code></pre><h4 id=\"2-2-查看版本\"><a href=\"#2-2-查看版本\" class=\"headerlink\" title=\"2.2   查看版本\"></a>2.2   查看版本</h4><pre><code>$ fastlane –v\n</code></pre><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/18.png\" alt=\"image\"></p>\n<h4 id=\"2-3-查看命令方法\"><a href=\"#2-3-查看命令方法\" class=\"headerlink\" title=\"2.3   查看命令方法\"></a>2.3   查看命令方法</h4><pre><code>$ fastlane actions\n</code></pre><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/19.png\" alt=\"image\"></p>\n<h4 id=\"2-4-查看指定方法\"><a href=\"#2-4-查看指定方法\" class=\"headerlink\" title=\"2.4   查看指定方法\"></a>2.4   查看指定方法</h4><pre><code>$ fastlane actions gym\n</code></pre><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/20.png\" alt=\"image\"></p>\n<h2 id=\"四、Jenkins新建Job\"><a href=\"#四、Jenkins新建Job\" class=\"headerlink\" title=\"四、Jenkins新建Job\"></a>四、Jenkins新建Job</h2><h3 id=\"1-新建一个item，选择自由风格的项目\"><a href=\"#1-新建一个item，选择自由风格的项目\" class=\"headerlink\" title=\"1    新建一个item，选择自由风格的项目\"></a>1    新建一个item，选择自由风格的项目</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/21.png\" alt=\"image\"></p>\n<h3 id=\"2-输入项目名称，描述等基本信息。\"><a href=\"#2-输入项目名称，描述等基本信息。\" class=\"headerlink\" title=\"2    输入项目名称，描述等基本信息。\"></a>2    输入项目名称，描述等基本信息。</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/22.png\" alt=\"image\"></p>\n<h3 id=\"3-源代码管理，因为使用的是SVN，所以选择Subversion。具体操作如下图所示：\"><a href=\"#3-源代码管理，因为使用的是SVN，所以选择Subversion。具体操作如下图所示：\" class=\"headerlink\" title=\"3 源代码管理，因为使用的是SVN，所以选择Subversion。具体操作如下图所示：\"></a>3 源代码管理，因为使用的是SVN，所以选择Subversion。具体操作如下图所示：</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/23.png\" alt=\"image\"><br>点击Add配置SVN用户信息。如下图所示：<br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/24.png\" alt=\"image\"><br>成功配置如下图所示：<br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/25.png\" alt=\"image\"></p>\n<h3 id=\"4-配置构建触发器\"><a href=\"#4-配置构建触发器\" class=\"headerlink\" title=\"4    配置构建触发器\"></a>4    配置构建触发器</h3><h4 id=\"4-1触发器支持多种类型，常用的有：\"><a href=\"#4-1触发器支持多种类型，常用的有：\" class=\"headerlink\" title=\"4.1触发器支持多种类型，常用的有：\"></a>4.1触发器支持多种类型，常用的有：</h4><pre><code>A 定期进行构建（Build periodically）\nB 根据提交进行构建（Build when a change is pushed to GitHub）\nC 定期检测代码更新，如有更新则进行构建（Poll SCM）\n</code></pre><p>构建触发器的选择为复合选项，若选择多种类型，则任一类型满足构建条件时就会执行构建工作。</p>\n<p>关于定时器（Schedule）的格式，简述如下：MINUTE HOUR DOM MONTH DOW</p>\n<pre><code>•  MINUTE: Minutes within the hour (0-59)\n•  HOUR: The hour of the day (0-23)\n•  DOM: The day of the month (1-31)\n•  MONTH: The month (1-12)\n•  DOW: The day of the week (0-7) where 0 and 7 are Sunday.\n</code></pre><p>通常情况下需要指定多个值，这时可以采用如下operator（优先级从上到下）：</p>\n<pre><code>•  *适配所有有效的值，若不指定某一项，则以*占位；\n•  M-N适配值域范围，例如7-9代表7/8/9均满足；\n•  M-N/X或*/X：以X作为间隔；\n•  A,B,C：枚举多个值。\n</code></pre><p>另外，为了避免多个任务在同一时刻同时触发构建，在指定时间段时可以配合使用H字符。添加H字符后，Jenkins会在指定时间段内随机选择一个时间点作为起始时刻，然后加上设定的时间间隔，计算得到后续的时间点。直到下一个周期时，Jenkins又会重新随机选择一个时间点作为起始时刻，依次类推。</p>\n<p>为了便于理解，列举几个示例：</p>\n<pre><code>•  H/15 * * * *：代表每隔15分钟，并且开始时间不确定，这个小时可能是:07,:22,:37,:52，下一个小时就可能是:03,:18,:33,:48；\n•  H(0-29)/10 * * * *：代表前半小时内每隔10分钟，并且开始时间不确定，这个小时可能是:04,:14,:24，下一个小时就可能是:09,:19,:29；\n•  H 23 * * 1-5：工作日每晚23:00至23:59之间的某一时刻；\n</code></pre><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/26.png\" alt=\"image\">    </p>\n<h3 id=\"5-构建环境（没有用到，暂未深入研究）\"><a href=\"#5-构建环境（没有用到，暂未深入研究）\" class=\"headerlink\" title=\"5    构建环境（没有用到，暂未深入研究）\"></a>5    构建环境（没有用到，暂未深入研究）</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/27.png\" alt=\"image\"></p>\n<h3 id=\"6-构建选择Execute-shell\"><a href=\"#6-构建选择Execute-shell\" class=\"headerlink\" title=\"6    构建选择Execute shell\"></a>6    构建选择Execute shell</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/28.png\" alt=\"image\"></p>\n<h4 id=\"Execute-shell代码段\"><a href=\"#Execute-shell代码段\" class=\"headerlink\" title=\"Execute shell代码段\"></a>Execute shell代码段</h4><pre><code>#!/bin/bash\n#计时\nSECONDS=0\n#假设脚本放置在与项目相同的路径下\nproject_path=$(pwd)\n# 创建build路径\nbuild_path=${project_path}/build\n# 清空并建立路径\nif [ -d ${build_path} ];then\nrm -rf ${build_path}; fi;\nmkdir ${build_path};\n\n#取当前时间字符串添加到文件结尾\nnow=$(date +&quot;%Y_%m_%d_%H_%M_%S&quot;)\n\n#指定项目的scheme名称\nscheme=$(ls | grep xcodeproj | awk -F.xcodeproj &apos;{print $1}&apos;)\n#指定要打包的配置名\nconfiguration=&quot;Release&quot;\n#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, development, 和developer-id，即xcodebuild的method参数\nexport_method=&apos;enterprise&apos;\n\n#info.plist路径\nproject_infoplist_path=&quot;$project_path/${scheme}/Info.plist&quot;\n#获取版本号\nbundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleShortVersionString&quot; &quot;${project_infoplist_path}&quot;)\n#清空并记录当前编译版本号\necho &gt; version.txt\necho &quot;${bundleShortVersion}&quot;&gt;&gt; version.txt\n\n#指定项目地址\nworkspace_path=&quot;$project_path/${scheme}.xcworkspace&quot;\n#指定输出路径\noutput_path=${build_path}\n#指定输出归档文件地址\narchive_path=&quot;$output_path/${scheme}_${now}.xcarchive&quot;\n#指定输出ipa地址\nipa_path=&quot;$output_path/${scheme}_${now}.ipa&quot;\n#指定输出ipa名称\nipa_name=&quot;${scheme}.ipa&quot;\n#获取执行命令时的commit message\ncommit_msg=&quot;$1&quot;\n\n#输出设定的变量值\necho &quot;===workspace path: ${workspace_path}===&quot;\necho &quot;===archive path: ${archive_path}===&quot;\necho &quot;===ipa path: ${ipa_path}===&quot;\necho &quot;===export method: ${export_method}===&quot;\necho &quot;===commit msg: $1===&quot;\n\n#先清空前一次build\nfastlane gym --workspace ${workspace_path} --scheme ${scheme} --clean --configuration ${configuration} --archive_path     ${archive_path} --export_method ${export_method} --output_directory ${output_path} --output_name ${ipa_name}\n\n#输出总用时\necho &quot;===Finished. Total time: ${SECONDS}s===&quot;\n</code></pre><h3 id=\"7-构建后操作增加邮件提醒，选择Editable-Email-Notification\"><a href=\"#7-构建后操作增加邮件提醒，选择Editable-Email-Notification\" class=\"headerlink\" title=\"7    构建后操作增加邮件提醒，选择Editable Email Notification\"></a>7    构建后操作增加邮件提醒，选择Editable Email Notification</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/29.png\" alt=\"image\"><br>配置触发操作：<br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/30.png\" alt=\"image\"><br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/31.png\" alt=\"image\"><br><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/32.png\" alt=\"image\"></p>\n<h3 id=\"8-构建后操作增加文件上传，选择Send-build-artifacts-over-FTP\"><a href=\"#8-构建后操作增加文件上传，选择Send-build-artifacts-over-FTP\" class=\"headerlink\" title=\"8    构建后操作增加文件上传，选择Send build artifacts over FTP\"></a>8    构建后操作增加文件上传，选择Send build artifacts over FTP</h3><p><img src=\"https://github.com/lxbboy326/jenkins-for-iOS-with-fastlane-and-svn/blob/master/resources/33.png\" alt=\"image\"></p>\n<h1 id=\"至此，Jenkins的安装配置完成，立即构建查看效果吧。\"><a href=\"#至此，Jenkins的安装配置完成，立即构建查看效果吧。\" class=\"headerlink\" title=\"至此，Jenkins的安装配置完成，立即构建查看效果吧。\"></a>至此，Jenkins的安装配置完成，立即构建查看效果吧。</h1>","slug":"20170224-Jenkins for iOS-刘小标","updated":"2018-09-28T08:52:59.184Z","comments":true,"link":"","permalink":"http://yoursite.com/2017/02/24/20170224-Jenkins for iOS-刘小标/","excerpt":"","categories":[{"name":"刘小标","slug":"刘小标","permalink":"http://yoursite.com/categories/刘小标/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/tags/IOS/"}]},{"title":"移动在线缓存","date":"2017-02-24T01:36:24.000Z","path":"2017/02/24/20170303-在线缓存(iOS)-汪洋/","text":"移动在线缓存一.在线缓存的必要性 众所周知，移动一张图目前包含两个应用场景：在线和离线。在线场景中，多用户共用数据，与云服务同步，实时性较强。而后者为单用户使用数据，无实时性要求，不常更新，需要数据拷贝，数据也能保证一定的隐秘性。那么在线缓存的应用场景突出在哪里呢？ ###1.在线离线一体化目前移动一张图的在线离线需要在登录时用户手动切换。而数据方面二者并不是同步的，在数据管理方面存在一定的弊端。而通过在线缓存即可实现多用户同步数据，具有较强的数据实时性,数据也便于云端管理。 ###2. 方便用户操作。 用户在在线与离线的应用场景中可以自由切换,比如在线过程中，临时切换，并不需要返回登录页面切换。 但同时，部分用户需要保证数据安全性（不需要在线版）,或者大部分使用场景都是离线,所以我们并不能将离线场景去除。 综述,在线、离线、在线缓存为3大应用场景。 二.在线缓存的可行性目前我们一张图主要数据有两类：地图数据和业务数据。而 ArcGIS for desktop 10.2.2以上已经支持两者缓存的技术可行性。具体条件如下： ArcGIS for desktop 版本为10.2.2或者 以上。 相关服务需要配置好设置(具体见后文) AGS-Runtime-SDK-iOS 10.2.5 业务数据需要通过Feature Service服务. 三. 支持在线缓存的服务设置 设置允许客户端导出切片 设置允许切片导出限制 发布 Feature Service 服务 四. iOS相关API与代码相关类与方法 AGSExportTileCacheTask AGSExportTileCacheParams AGSGDBSyncTask AGSGDBGenerateParameters exportTileCacheWithParameters estimateTileCacheSizeWithParameters generateGeodatabaseWithParameters 初始化底图与要素let huaianServiceUrl = &quot;http://192.168.1.162:6080/arcgis/rest/services/test3/MapServer&quot; let huaianFeatureUrl = &quot;http://192.168.1.162:6080/arcgis/rest/services/test4/FeatureServer&quot; class ViewController: UIViewController,AGSLayerDelegate { @IBOutlet var mapView: AGSMapView! var mapLayer: AGSTiledMapServiceLayer! var tileCacheTask: AGSExportTileCacheTask! var gdbTask: AGSGDBSyncTask! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. self.mapLayer = AGSTiledMapServiceLayer(URL: NSURL(string: huaianServiceUrl)) self.mapLayer.delegate = self mapView.addMapLayer(mapLayer) if self.tileCacheTask == nil { self.tileCacheTask = AGSExportTileCacheTask(URL: NSURL(string: huaianServiceUrl)) } } func layerDidLoad(layer: AGSLayer!) { if layer == self.mapLayer { gdbTask = AGSGDBSyncTask(URL: NSURL(string: huaianFeatureUrl)) gdbTask.loadCompletion = { error in if error != nil { print(error.localizedDescription) } for info in self.gdbTask.featureServiceInfo.layerInfos as! [AGSMapServiceLayerInfo] { let url = self.gdbTask.URL.URLByAppendingPathComponent(&quot;\\(info.layerId)&quot;) let featureServiceTable = AGSGDBFeatureServiceTable(serviceURL: url, credential: self.gdbTask.credential, spatialReference: self.mapView.spatialReference) let featureLayer = AGSFeatureTableLayer(featureTable:featureServiceTable) self.mapView.addMapLayer(featureLayer) } } } } 下载底图形成tpk文件@IBAction func downloadTpkAction(sender: UIBarButtonItem) { SVProgressHUD.showWithStatus(&quot;准备下载&quot;) let levels = [self.mapLayer.currentLOD().level] let extent = self.mapView.visibleAreaEnvelope //let extent = AGSEnvelope(xmin: 610875.41170353664, ymin: 3780046.638612428, xmax: 610948.9641964633, ymax: 3780074.6404850003, spatialReference: self.mapView.spatialReference) let params = AGSExportTileCacheParams(levelsOfDetail: levels, areaOfInterest: extent) //showSizesOfTpk(params) downloadTileCache(params) } func downloadTileCache(params: AGSExportTileCacheParams) { let tpkPath = NSHomeDirectory() + &quot;/Documents&quot; + &quot;/tpk&quot; self.tileCacheTask.exportTileCacheWithParameters(params, downloadFolderPath: tpkPath, useExisting: true, status: { (status, userInfo) in print(&quot;\\(AGSResumableTaskJobStatusAsString(status)), \\(userInfo)&quot;) let totalBytesDownloaded: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesDownloaded&quot;] let totalBytesExpected: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesExpected&quot;] if totalBytesDownloaded != nil &amp;&amp; totalBytesExpected != nil { let dPercentage = Float(totalBytesDownloaded! as! NSNumber)/Float(totalBytesExpected! as! NSNumber) SVProgressHUD.showProgress(dPercentage, status: &quot;下载中&quot;) if dPercentage == 1 { SVProgressHUD.dismiss() } print(dPercentage) } }) { (tiledLayer, error) in if error != nil { SVProgressHUD.showErrorWithStatus(error.localizedDescription) } self.mapView.reset() self.mapView.addMapLayer(tiledLayer, withName:&quot;offline&quot;) } } ###下载要素形成 gdb @IBAction func downloadGdbAction(sender: UIBarButtonItem) { SVProgressHUD.showWithStatus(&quot;准备下载&quot;) let gdbPath = NSHomeDirectory() + &quot;/Documents&quot; + &quot;/gdb&quot; let params = AGSGDBGenerateParameters(featureServiceInfo: self.gdbTask.featureServiceInfo) params.extent = self.mapView.maxEnvelope params.outSpatialReference = self.mapView.spatialReference let layers = self.gdbTask.featureServiceInfo.layerInfos.map { layerInfo -&gt; Int in layerInfo.layerId } params.layerIDs = layers self.gdbTask.generateGeodatabaseWithParameters(params, downloadFolderPath: gdbPath, useExisting: true, status: { (status, userInfo) in print(AGSResumableTaskJobStatusAsString(status)) let totalBytesDownloaded: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesDownloaded&quot;] let totalBytesExpected: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesExpected&quot;] if totalBytesDownloaded != nil &amp;&amp; totalBytesExpected != nil { let dPercentage = Float(totalBytesDownloaded! as! NSNumber)/Float(totalBytesExpected! as! NSNumber) SVProgressHUD.showProgress(dPercentage, status: &quot;下载中&quot;) if dPercentage == 1 { SVProgressHUD.dismiss() } print(dPercentage) } }) { (gdb, error) in if error != nil { print(error) } for layer in self.mapView.mapLayers as! [AGSLayer] { if layer is AGSFeatureTableLayer { self.mapView.removeMapLayer(layer) } } if gdb.featureTables().count &gt; 0 { for table in gdb.featureTables() as! [AGSFeatureTable]{ if table.hasGeometry() { let tableLayer = AGSFeatureTableLayer(featureTable: table) self.mapView.addMapLayer(tableLayer) } } } } } 五. 总结与后续问题思考 经过研究实践，移动在线缓存技术是完全可行的,详见 CacheDemo","raw":"---\ntitle: 移动在线缓存\ndate: 2017-02-24 09:36:24\ntags: IOS\ncategories: 汪洋\n---\n# 移动在线缓存\n\n## 一.在线缓存的必要性\n   众所周知，移动一张图目前包含两个应用场景：在线和离线。在线场景中，多用户共用数据，与云服务同步，实时性较强。而后者为单用户使用数据，无实时性要求，不常更新，需要数据拷贝，数据也能保证一定的隐秘性。那么在线缓存的应用场景突出在哪里呢？\n###1.在线离线一体化\n目前移动一张图的在线离线需要在登录时用户手动切换。而数据方面二者并不是同步的，在数据管理方面存在一定的弊端。而通过在线缓存即可实现多用户同步数据，具有较强的数据实时性,数据也便于云端管理。\n###2. 方便用户操作。\n\n用户在在线与离线的应用场景中可以自由切换,比如在线过程中，临时切换，并不需要返回登录页面切换。\n\n但同时，部分用户需要保证数据安全性（不需要在线版）,或者大部分使用场景都是离线,所以我们并不能将离线场景去除。\n\n综述,在线、离线、在线缓存为3大应用场景。\n\n## 二.在线缓存的可行性\n目前我们一张图主要数据有两类：地图数据和业务数据。而 ArcGIS for desktop 10.2.2以上已经支持两者缓存的技术可行性。具体条件如下：\n\n* ArcGIS for desktop 版本为10.2.2或者 以上。\n* 相关服务需要配置好设置(具体见后文)\n* AGS-Runtime-SDK-iOS 10.2.5 \n* 业务数据需要通过Feature Service服务.\n\n## 三. 支持在线缓存的服务设置\n* 设置允许客户端导出切片\n* 设置允许切片导出限制\n* 发布[ *Feature Service* ](http://www.cnblogs.com/gis-luq/p/5857188.html)服务\n\n## 四. iOS相关API与代码\n### 相关类与方法\n* `AGSExportTileCacheTask`\n* `AGSExportTileCacheParams`\n* `AGSGDBSyncTask `\n* `AGSGDBGenerateParameters `\n* `exportTileCacheWithParameters`\n* `estimateTileCacheSizeWithParameters`\n* `generateGeodatabaseWithParameters`\n\n### 初始化底图与要素\n\tlet huaianServiceUrl = \"http://192.168.1.162:6080/arcgis/rest/services/test3/MapServer\"\n\tlet huaianFeatureUrl = \"http://192.168.1.162:6080/arcgis/rest/services/test4/FeatureServer\"\n\n\tclass ViewController: UIViewController,AGSLayerDelegate {\n\n    @IBOutlet var mapView: AGSMapView!\n    \n    var mapLayer: AGSTiledMapServiceLayer!\n    \n    var tileCacheTask: AGSExportTileCacheTask!\n    \n    var gdbTask: AGSGDBSyncTask!\n    \n    \n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        // Do any additional setup after loading the view, typically from a nib.\n      \n        self.mapLayer = AGSTiledMapServiceLayer(URL: NSURL(string: huaianServiceUrl))\n        self.mapLayer.delegate = self\n        mapView.addMapLayer(mapLayer)\n        \n        if self.tileCacheTask == nil {\n            self.tileCacheTask = AGSExportTileCacheTask(URL: NSURL(string: huaianServiceUrl))\n        }\n        \n    }\n\tfunc layerDidLoad(layer: AGSLayer!) {\n        if layer == self.mapLayer {\n        gdbTask = AGSGDBSyncTask(URL: NSURL(string: huaianFeatureUrl))\n        gdbTask.loadCompletion = {\n            error in\n            if error != nil {\n                print(error.localizedDescription)\n            }\n            for info in self.gdbTask.featureServiceInfo.layerInfos as! [AGSMapServiceLayerInfo] {\n                let url = self.gdbTask.URL.URLByAppendingPathComponent(\"\\(info.layerId)\")\n                let featureServiceTable = AGSGDBFeatureServiceTable(serviceURL: url, credential: self.gdbTask.credential, spatialReference: self.mapView.spatialReference)\n                let featureLayer = AGSFeatureTableLayer(featureTable:featureServiceTable)\n                self.mapView.addMapLayer(featureLayer)\n                \n            }\n        }\n        }\n\n    }\n \n### 下载底图形成tpk文件\n\t@IBAction func downloadTpkAction(sender: UIBarButtonItem) {\n        \n        \n        SVProgressHUD.showWithStatus(\"准备下载\")\n        let levels = [self.mapLayer.currentLOD().level]\n        let extent = self.mapView.visibleAreaEnvelope\n        \n        //let extent = AGSEnvelope(xmin: 610875.41170353664, ymin: 3780046.638612428, xmax: 610948.9641964633, ymax: 3780074.6404850003, spatialReference: self.mapView.spatialReference)\n        \n        let params = AGSExportTileCacheParams(levelsOfDetail: levels, areaOfInterest: extent)\n        \n        \n        //showSizesOfTpk(params)\n        downloadTileCache(params)\n        \n    }\n\n\tfunc downloadTileCache(params: AGSExportTileCacheParams) {\n        \n        let tpkPath = NSHomeDirectory() + \"/Documents\" + \"/tpk\"\n        \n        self.tileCacheTask.exportTileCacheWithParameters(params, downloadFolderPath: tpkPath, useExisting: true, status: { (status, userInfo) in\n            print(\"\\(AGSResumableTaskJobStatusAsString(status)), \\(userInfo)\")\n            let totalBytesDownloaded: AnyObject? = userInfo?[\"AGSDownloadProgressTotalBytesDownloaded\"]\n            let totalBytesExpected: AnyObject? = userInfo?[\"AGSDownloadProgressTotalBytesExpected\"]\n            if totalBytesDownloaded != nil && totalBytesExpected != nil {\n                let dPercentage = Float(totalBytesDownloaded! as! NSNumber)/Float(totalBytesExpected! as! NSNumber)\n                SVProgressHUD.showProgress(dPercentage, status: \"下载中\")\n                if dPercentage == 1 {\n                    SVProgressHUD.dismiss()\n                }\n                print(dPercentage)\n        \n            } }) { (tiledLayer, error) in\n                \n                if error != nil {\n                    SVProgressHUD.showErrorWithStatus(error.localizedDescription)\n                }\n                self.mapView.reset()\n                self.mapView.addMapLayer(tiledLayer, withName:\"offline\")\n\n        }\n    }\n\n###下载要素形成 gdb\n\t@IBAction func downloadGdbAction(sender: UIBarButtonItem) {\n    \n        SVProgressHUD.showWithStatus(\"准备下载\")\n\n        let gdbPath = NSHomeDirectory() + \"/Documents\" + \"/gdb\"\n        let params = AGSGDBGenerateParameters(featureServiceInfo: self.gdbTask.featureServiceInfo)\n       \n        params.extent = self.mapView.maxEnvelope\n\n        params.outSpatialReference = self.mapView.spatialReference\n        let layers = self.gdbTask.featureServiceInfo.layerInfos.map { layerInfo -> Int in layerInfo.layerId\n        }\n        params.layerIDs = layers\n        \n        self.gdbTask.generateGeodatabaseWithParameters(params, downloadFolderPath: gdbPath, useExisting: true, status: {\n            (status, userInfo) in\n                print(AGSResumableTaskJobStatusAsString(status))\n            let totalBytesDownloaded: AnyObject? = userInfo?[\"AGSDownloadProgressTotalBytesDownloaded\"]\n            let totalBytesExpected: AnyObject? = userInfo?[\"AGSDownloadProgressTotalBytesExpected\"]\n            if totalBytesDownloaded != nil && totalBytesExpected != nil {\n                let dPercentage = Float(totalBytesDownloaded! as! NSNumber)/Float(totalBytesExpected! as! NSNumber)\n                SVProgressHUD.showProgress(dPercentage, status: \"下载中\")\n                if dPercentage == 1 {\n                    SVProgressHUD.dismiss()\n                }\n                print(dPercentage)\n            }\n            }) { (gdb, error) in\n                if error != nil {\n                    print(error)\n                }\n                for layer in self.mapView.mapLayers as! [AGSLayer] {\n                    if layer is AGSFeatureTableLayer {\n                        self.mapView.removeMapLayer(layer)\n                    }\n                }\n                if gdb.featureTables().count > 0 {\n                    for table in gdb.featureTables() as! [AGSFeatureTable]{\n                        if table.hasGeometry() {\n                        let tableLayer = AGSFeatureTableLayer(featureTable: table)\n                        self.mapView.addMapLayer(tableLayer)\n                        }\n               }           }\n        }   \n    }\n\n五. 总结与后续问题思考\n\t\n经过研究实践，移动在线缓存技术是完全可行的,详见 CacheDemo","content":"<h1 id=\"移动在线缓存\"><a href=\"#移动在线缓存\" class=\"headerlink\" title=\"移动在线缓存\"></a>移动在线缓存</h1><h2 id=\"一-在线缓存的必要性\"><a href=\"#一-在线缓存的必要性\" class=\"headerlink\" title=\"一.在线缓存的必要性\"></a>一.在线缓存的必要性</h2><p>   众所周知，移动一张图目前包含两个应用场景：在线和离线。在线场景中，多用户共用数据，与云服务同步，实时性较强。而后者为单用户使用数据，无实时性要求，不常更新，需要数据拷贝，数据也能保证一定的隐秘性。那么在线缓存的应用场景突出在哪里呢？</p>\n<p>###1.在线离线一体化<br>目前移动一张图的在线离线需要在登录时用户手动切换。而数据方面二者并不是同步的，在数据管理方面存在一定的弊端。而通过在线缓存即可实现多用户同步数据，具有较强的数据实时性,数据也便于云端管理。</p>\n<p>###2. 方便用户操作。</p>\n<p>用户在在线与离线的应用场景中可以自由切换,比如在线过程中，临时切换，并不需要返回登录页面切换。</p>\n<p>但同时，部分用户需要保证数据安全性（不需要在线版）,或者大部分使用场景都是离线,所以我们并不能将离线场景去除。</p>\n<p>综述,在线、离线、在线缓存为3大应用场景。</p>\n<h2 id=\"二-在线缓存的可行性\"><a href=\"#二-在线缓存的可行性\" class=\"headerlink\" title=\"二.在线缓存的可行性\"></a>二.在线缓存的可行性</h2><p>目前我们一张图主要数据有两类：地图数据和业务数据。而 ArcGIS for desktop 10.2.2以上已经支持两者缓存的技术可行性。具体条件如下：</p>\n<ul>\n<li>ArcGIS for desktop 版本为10.2.2或者 以上。</li>\n<li>相关服务需要配置好设置(具体见后文)</li>\n<li>AGS-Runtime-SDK-iOS 10.2.5 </li>\n<li>业务数据需要通过Feature Service服务.</li>\n</ul>\n<h2 id=\"三-支持在线缓存的服务设置\"><a href=\"#三-支持在线缓存的服务设置\" class=\"headerlink\" title=\"三. 支持在线缓存的服务设置\"></a>三. 支持在线缓存的服务设置</h2><ul>\n<li>设置允许客户端导出切片</li>\n<li>设置允许切片导出限制</li>\n<li>发布<a href=\"http://www.cnblogs.com/gis-luq/p/5857188.html\" target=\"_blank\" rel=\"noopener\"> <em>Feature Service</em> </a>服务</li>\n</ul>\n<h2 id=\"四-iOS相关API与代码\"><a href=\"#四-iOS相关API与代码\" class=\"headerlink\" title=\"四. iOS相关API与代码\"></a>四. iOS相关API与代码</h2><h3 id=\"相关类与方法\"><a href=\"#相关类与方法\" class=\"headerlink\" title=\"相关类与方法\"></a>相关类与方法</h3><ul>\n<li><code>AGSExportTileCacheTask</code></li>\n<li><code>AGSExportTileCacheParams</code></li>\n<li><code>AGSGDBSyncTask</code></li>\n<li><code>AGSGDBGenerateParameters</code></li>\n<li><code>exportTileCacheWithParameters</code></li>\n<li><code>estimateTileCacheSizeWithParameters</code></li>\n<li><code>generateGeodatabaseWithParameters</code></li>\n</ul>\n<h3 id=\"初始化底图与要素\"><a href=\"#初始化底图与要素\" class=\"headerlink\" title=\"初始化底图与要素\"></a>初始化底图与要素</h3><pre><code>let huaianServiceUrl = &quot;http://192.168.1.162:6080/arcgis/rest/services/test3/MapServer&quot;\nlet huaianFeatureUrl = &quot;http://192.168.1.162:6080/arcgis/rest/services/test4/FeatureServer&quot;\n\nclass ViewController: UIViewController,AGSLayerDelegate {\n\n@IBOutlet var mapView: AGSMapView!\n\nvar mapLayer: AGSTiledMapServiceLayer!\n\nvar tileCacheTask: AGSExportTileCacheTask!\n\nvar gdbTask: AGSGDBSyncTask!\n\n\n\noverride func viewDidLoad() {\n    super.viewDidLoad()\n    // Do any additional setup after loading the view, typically from a nib.\n\n    self.mapLayer = AGSTiledMapServiceLayer(URL: NSURL(string: huaianServiceUrl))\n    self.mapLayer.delegate = self\n    mapView.addMapLayer(mapLayer)\n\n    if self.tileCacheTask == nil {\n        self.tileCacheTask = AGSExportTileCacheTask(URL: NSURL(string: huaianServiceUrl))\n    }\n\n}\nfunc layerDidLoad(layer: AGSLayer!) {\n    if layer == self.mapLayer {\n    gdbTask = AGSGDBSyncTask(URL: NSURL(string: huaianFeatureUrl))\n    gdbTask.loadCompletion = {\n        error in\n        if error != nil {\n            print(error.localizedDescription)\n        }\n        for info in self.gdbTask.featureServiceInfo.layerInfos as! [AGSMapServiceLayerInfo] {\n            let url = self.gdbTask.URL.URLByAppendingPathComponent(&quot;\\(info.layerId)&quot;)\n            let featureServiceTable = AGSGDBFeatureServiceTable(serviceURL: url, credential: self.gdbTask.credential, spatialReference: self.mapView.spatialReference)\n            let featureLayer = AGSFeatureTableLayer(featureTable:featureServiceTable)\n            self.mapView.addMapLayer(featureLayer)\n\n        }\n    }\n    }\n\n}\n</code></pre><h3 id=\"下载底图形成tpk文件\"><a href=\"#下载底图形成tpk文件\" class=\"headerlink\" title=\"下载底图形成tpk文件\"></a>下载底图形成tpk文件</h3><pre><code>@IBAction func downloadTpkAction(sender: UIBarButtonItem) {\n\n\n    SVProgressHUD.showWithStatus(&quot;准备下载&quot;)\n    let levels = [self.mapLayer.currentLOD().level]\n    let extent = self.mapView.visibleAreaEnvelope\n\n    //let extent = AGSEnvelope(xmin: 610875.41170353664, ymin: 3780046.638612428, xmax: 610948.9641964633, ymax: 3780074.6404850003, spatialReference: self.mapView.spatialReference)\n\n    let params = AGSExportTileCacheParams(levelsOfDetail: levels, areaOfInterest: extent)\n\n\n    //showSizesOfTpk(params)\n    downloadTileCache(params)\n\n}\n\nfunc downloadTileCache(params: AGSExportTileCacheParams) {\n\n    let tpkPath = NSHomeDirectory() + &quot;/Documents&quot; + &quot;/tpk&quot;\n\n    self.tileCacheTask.exportTileCacheWithParameters(params, downloadFolderPath: tpkPath, useExisting: true, status: { (status, userInfo) in\n        print(&quot;\\(AGSResumableTaskJobStatusAsString(status)), \\(userInfo)&quot;)\n        let totalBytesDownloaded: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesDownloaded&quot;]\n        let totalBytesExpected: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesExpected&quot;]\n        if totalBytesDownloaded != nil &amp;&amp; totalBytesExpected != nil {\n            let dPercentage = Float(totalBytesDownloaded! as! NSNumber)/Float(totalBytesExpected! as! NSNumber)\n            SVProgressHUD.showProgress(dPercentage, status: &quot;下载中&quot;)\n            if dPercentage == 1 {\n                SVProgressHUD.dismiss()\n            }\n            print(dPercentage)\n\n        } }) { (tiledLayer, error) in\n\n            if error != nil {\n                SVProgressHUD.showErrorWithStatus(error.localizedDescription)\n            }\n            self.mapView.reset()\n            self.mapView.addMapLayer(tiledLayer, withName:&quot;offline&quot;)\n\n    }\n}\n</code></pre><p>###下载要素形成 gdb<br>    @IBAction func downloadGdbAction(sender: UIBarButtonItem) {</p>\n<pre><code>    SVProgressHUD.showWithStatus(&quot;准备下载&quot;)\n\n    let gdbPath = NSHomeDirectory() + &quot;/Documents&quot; + &quot;/gdb&quot;\n    let params = AGSGDBGenerateParameters(featureServiceInfo: self.gdbTask.featureServiceInfo)\n\n    params.extent = self.mapView.maxEnvelope\n\n    params.outSpatialReference = self.mapView.spatialReference\n    let layers = self.gdbTask.featureServiceInfo.layerInfos.map { layerInfo -&gt; Int in layerInfo.layerId\n    }\n    params.layerIDs = layers\n\n    self.gdbTask.generateGeodatabaseWithParameters(params, downloadFolderPath: gdbPath, useExisting: true, status: {\n        (status, userInfo) in\n            print(AGSResumableTaskJobStatusAsString(status))\n        let totalBytesDownloaded: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesDownloaded&quot;]\n        let totalBytesExpected: AnyObject? = userInfo?[&quot;AGSDownloadProgressTotalBytesExpected&quot;]\n        if totalBytesDownloaded != nil &amp;&amp; totalBytesExpected != nil {\n            let dPercentage = Float(totalBytesDownloaded! as! NSNumber)/Float(totalBytesExpected! as! NSNumber)\n            SVProgressHUD.showProgress(dPercentage, status: &quot;下载中&quot;)\n            if dPercentage == 1 {\n                SVProgressHUD.dismiss()\n            }\n            print(dPercentage)\n        }\n        }) { (gdb, error) in\n            if error != nil {\n                print(error)\n            }\n            for layer in self.mapView.mapLayers as! [AGSLayer] {\n                if layer is AGSFeatureTableLayer {\n                    self.mapView.removeMapLayer(layer)\n                }\n            }\n            if gdb.featureTables().count &gt; 0 {\n                for table in gdb.featureTables() as! [AGSFeatureTable]{\n                    if table.hasGeometry() {\n                    let tableLayer = AGSFeatureTableLayer(featureTable: table)\n                    self.mapView.addMapLayer(tableLayer)\n                    }\n           }           }\n    }   \n}\n</code></pre><p>五. 总结与后续问题思考</p>\n<p>经过研究实践，移动在线缓存技术是完全可行的,详见 CacheDemo</p>\n","slug":"20170303-在线缓存(iOS)-汪洋","updated":"2018-09-28T08:56:39.850Z","comments":true,"link":"","permalink":"http://yoursite.com/2017/02/24/20170303-在线缓存(iOS)-汪洋/","excerpt":"","categories":[{"name":"汪洋","slug":"汪洋","permalink":"http://yoursite.com/categories/汪洋/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/tags/IOS/"}]}]}